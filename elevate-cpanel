#!/usr/local/cpanel/3rdparty/bin/perl

## ----------------------------------------------------------------------------
##
## DO NOT EDIT THIS FILE
##
## This file is automatically generated from script/elevate-cpanel.PL
##
## view https://github.com/cpanel/elevate for more details
##
## ----------------------------------------------------------------------------

BEGIN {    # Suppress load of all of these at earliest point.
    $INC{'Elevate/Constants.pm'}               = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/Base.pm'}           = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers.pm'}                = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/Databases.pm'}      = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/DiskSpace.pm'}      = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/Distros.pm'}        = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/DNS.pm'}            = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/EA4.pm'}            = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/ElevateScript.pm'}  = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/Grub2.pm'}          = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/IsContainer.pm'}    = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/JetBackup.pm'}      = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/NICs.pm'}           = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/OVH.pm'}            = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/Repositories.pm'}   = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/SSH.pm'}            = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Blockers/WHM.pm'}            = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/ArchRPMs.pm'}     = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/Base.pm'}         = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/DigitalOcean.pm'} = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/EA4.pm'}          = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/Grub2.pm'}        = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/Imunify.pm'}      = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/Imunify360.pm'}   = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/InfluxDB.pm'}     = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/JetBackup.pm'}    = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/LiteSpeed.pm'}    = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/KernelCare.pm'}   = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/Kernel.pm'}       = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/MySQL.pm'}        = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/NixStats.pm'}     = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/PECL.pm'}         = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/PerlXS.pm'}       = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/Repositories.pm'} = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Components/WPToolkit.pm'}    = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Fetch.pm'}                   = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Logger.pm'}                  = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Motd.pm'}                    = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Notify.pm'}                  = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Roles/Run.pm'}               = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Script.pm'}                  = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Service.pm'}                 = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/SystemctlService.pm'}        = 'script/elevate-cpanel.PL.static';
    $INC{'Elevate/Usage.pm'}                   = 'script/elevate-cpanel.PL.static';
}

{    # --- BEGIN lib/Elevate/Constants.pm

    package Elevate::Constants;

    use constant MINIMUM_LTS_SUPPORTED => 102;

    use constant SERVICE_DIR  => '/etc/systemd/system/';
    use constant SERVICE_NAME => 'elevate-cpanel.service';

    use constant LOG_FILE => q[/var/log/elevate-cpanel.log];
    use constant PID_FILE => q[/var/run/elevate-cpanel.pid];

    use constant DEFAULT_GRUB_FILE => '/etc/default/grub';

    use constant YUM_REPOS_D => q[/etc/yum.repos.d];

    use constant ELEVATE_BACKUP_DIR => "/root/.elevate.backup";

    use constant IMUNIFY_AGENT => '/usr/bin/imunify360-agent';

    1;

}    # --- END lib/Elevate/Constants.pm

{    # --- BEGIN lib/Elevate/Blockers/Base.pm

    package Elevate::Blockers::Base;

    use cPstrict;

    use Simple::Accessor qw(
      blockers
      cpconf
    );

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub _build_blockers {
        if ( $0 =~ qr{\bt/} ) {
            return Elevate::Blockers->new;
        }
        die q[Missing blockers];
    }

    sub cpev ($self) {
        return $self->blockers->cpev;
    }

    BEGIN {
        my @_DELEGATE_TO_CPEV = qw{
          getopt
          update_stage_file
          upgrade_to_rocky
          upgrade_to_pretty_name
          ssystem
          ssystem_capture_output
        };

        foreach my $subname (@_DELEGATE_TO_CPEV) {
            no strict 'refs';
            *$subname = sub ( $self, @args ) {
                my $cpev = $self->cpev;
                my $sub  = $cpev->can($subname) or die qq[cpev does not support $subname];
                return $sub->( $cpev, @args );
            }
        }
    }

    sub _build_cpconf ($self) {
        return Cpanel::Config::LoadCpConf::loadcpconf() // {};
    }

    sub is_check_mode ( $self, @args ) {
        return $self->blockers->is_check_mode(@args);
    }

    sub has_blocker ( $self, $msg, %others ) {

        my ( undef, undef, undef, $id ) = caller(1);
        $id ||= ref $self;

        my $blocker = cpev::Blocker->new( id => $id, msg => $msg, %others );
        die $blocker if $self->cpev->_abort_on_first_blocker;

        WARN( <<~"EOS");
    *** Elevation Blocker detected: ***
    $msg
    EOS

        $self->blockers->add_blocker($blocker);

        return $blocker;
    }

    {

        package cpev::Blocker;

        use Simple::Accessor qw{ id msg };

        sub TO_JSON ($self) {
            my %hash = $self->%*;
            return \%hash;
        }
    }

    1;

}    # --- END lib/Elevate/Blockers/Base.pm

{    # --- BEGIN lib/Elevate/Blockers.pm

    package Elevate::Blockers;

    use cPstrict;

    use Elevate::Blockers::Base ();

    use Elevate::Blockers::Databases     ();
    use Elevate::Blockers::DiskSpace     ();
    use Elevate::Blockers::Distros       ();
    use Elevate::Blockers::DNS           ();
    use Elevate::Blockers::EA4           ();
    use Elevate::Blockers::Grub2         ();
    use Elevate::Blockers::IsContainer   ();
    use Elevate::Blockers::JetBackup     ();
    use Elevate::Blockers::NICs          ();
    use Elevate::Blockers::OVH           ();
    use Elevate::Blockers::ElevateScript ();
    use Elevate::Blockers::SSH           ();
    use Elevate::Blockers::WHM           ();
    use Elevate::Blockers::Repositories  ();

    use Simple::Accessor qw(
      cpev
      check_mode
      blockers
    );

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }
    use Cpanel::JSON ();

    our @BLOCKERS = qw{

      IsContainer
      ElevateScript

      DiskSpace
      WHM
      Distros
      DNS

      Databases
      Repositories
      SSH
      JetBackup
      NICs
      EA4
      Grub2
      OVH
    };

    use constant ELEVATE_BLOCKER_FILE => '/var/cpanel/elevate-blockers';

    our $_CHECK_MODE;    # for now global so we can use the helper (move it later to the object)

    sub _build_blockers { [] }

    sub check ($self) {    # do_check - main  entry point

        if ( $self->cpev->service->is_active ) {
            WARN("An elevation process is already in progress.");
            return 1;
        }

        Elevate::Blockers::Distros::bail_out_on_inappropriate_distro();

        my $blocker_file = $self->cpev->getopt('check') || ELEVATE_BLOCKER_FILE;

        my $has_blockers = $self->_has_blockers(1);

        $self->save( $blocker_file, { 'blockers' => $self->{'blockers'} } );

        if ($has_blockers) {
            WARN( <<~'EOS' );
        Please fix the detected issues before performing the elevation process.
        EOS
        }
        else {
            INFO( <<~'EOS' );
        There is no known blockers to start the elevation process.
        You can consider running:
            /scripts/elevate-cpanel --start
        EOS
        }

        return $has_blockers;
    }

    sub _has_blockers ( $self, $check_mode = 0 ) {

        unless ( $< == 0 ) {
            ERROR("This script can only be run by root");
            return 666;
        }

        $_CHECK_MODE = !!$check_mode;                              # running with --check
        $self->cpev->{_abort_on_first_blocker} = !$_CHECK_MODE;    # abort on first blocker

        my $ok = eval { $self->_check_all_blockers; 1; };

        if ( !$ok ) {
            my $error = $@;
            if ( ref $error eq 'cpev::Blocker' ) {
                ERROR( $error->{msg} );
                return $error->{id} // 401;
            }
            WARN("Unknown error while checking blockers: $error");
            return 127;    # unknown error
        }

        return scalar $self->blockers->@*;
    }

    sub add_blocker ( $self, $blocker ) {
        push $self->blockers->@*, $blocker;
        return;
    }

    sub is_check_mode ($) {
        return $_CHECK_MODE;
    }

    sub save ( $self, $path, $stash ) {

        open( my $fh, '>', $path ) or LOGDIE( "Fail to open " . $path . ": $!" );

        print {$fh} Cpanel::JSON::pretty_canonical_dump($stash);
        close $fh;

        return 1;
    }

    sub _check_all_blockers ($self) {    # sub _blockers_check ($self) {

        foreach my $blocker (@BLOCKERS) {    # preserve order
            $self->_check_single_blocker($blocker);
        }

        return 0;
    }

    sub _check_single_blocker ( $self, $name ) {
        my $blocker = $self->_get_blocker_for($name);

        my $check = $blocker->can('check')
          or die qq[Missing check function from ] . ref($blocker);

        return $check->($blocker);
    }

    sub _get_blocker_for ( $self, $name ) {    # useful for tests
        my $pkg = "Elevate::Blockers::$name";    # need to be loaded
        return $pkg->new( blockers => $self );
    }

    1;

}    # --- END lib/Elevate/Blockers.pm

{    # --- BEGIN lib/Elevate/Blockers/Databases.pm

    package Elevate::Blockers::Databases;

    use cPstrict;

    use Cpanel::OS            ();
    use Cpanel::Version::Tiny ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {
        $self->_warning_if_postgresql_installed;
        my $ok = $self->_blocker_old_mysql;
        $ok = 0 unless $self->_blocker_mysql_upgrade_in_progress;

        return $ok;
    }

    sub _warning_if_postgresql_installed ($self) {
        return 0 unless Cpanel::Pkgr::is_installed('postgresql-server');

        my $pg_full_ver = Cpanel::Pkgr::get_package_version('postgresql-server');
        my ($old_version) = $pg_full_ver =~ m/^(\d+\.\d+)/a;
        return 1 if !$old_version || $old_version >= 10;

        my $pretty_distro_name = $self->upgrade_to_pretty_name();
        WARN("You have postgresql-server version $old_version installed. This will be upgraded irreversibly to version 10.0 when you switch to $pretty_distro_name");

        return 2;
    }

    sub _blocker_old_mysql ( $self, $mysql_version = undef ) {

        $mysql_version //= $self->cpconf->{'mysql-version'} // '';

        my $pretty_distro_name = $self->upgrade_to_pretty_name();

        if ( $mysql_version =~ qr{^\d+(\.\d)?$}a ) {
            if ( 5 <= $mysql_version && $mysql_version <= 5.7 ) {
                return $self->has_blocker( <<~"EOS");
            You are using MySQL $mysql_version server.
            This version is not available for $pretty_distro_name.
            You first need to update your MySQL server to 8.0 or later.

            You can update to version 8.0 using the following command:

                /usr/local/cpanel/bin/whmapi1 start_background_mysql_upgrade version=8.0

            Once the MySQL upgrade is finished, you can then retry to elevate to $pretty_distro_name.
            EOS
            }
            elsif ( 10 <= $mysql_version && $mysql_version <= 10.2 ) {

                my $upgrade_version = $Cpanel::Version::Tiny::major_version <= 108 ? '10.3' : '10.5';

                return $self->has_blocker( <<~"EOS");
            You are using MariaDB server $mysql_version, this version is not available for $pretty_distro_name.
            You first need to update MariaDB server to $upgrade_version or later.

            You can update to version $upgrade_version using the following command:

                /usr/local/cpanel/bin/whmapi1 start_background_mysql_upgrade version=$upgrade_version

            Once the MariaDB upgrade is finished, you can then retry to elevate to $pretty_distro_name.
            EOS
            }
        }

        my %supported_mysql_versions = (
            map { $_ => 1 }
              qw{
              8.0
              10.3
              10.4
              10.5
              10.6
              }
        );

        if ( !$supported_mysql_versions{$mysql_version} ) {
            my $supported_version_str = join( ", ", sort { $a <=> $b } keys %supported_mysql_versions );
            return $self->has_blocker( <<~"EOS");
            We do not know how to upgrade to $pretty_distro_name with MySQL version $mysql_version.
            Please upgrade your MySQL server to one of the supported versions before running elevate.

            Supported MySQL server versions are: $supported_version_str
            EOS
        }

        cpev::update_stage_file( { 'mysql-version' => $mysql_version } );

        return 0;
    }

    sub _blocker_mysql_upgrade_in_progress ($self) {
        if ( -e q[/var/cpanel/mysql_upgrade_in_progress] ) {
            return $self->has_blocker(q[MySQL upgrade in progress. Please wait for the MySQL upgrade to finish.]);
        }

        return 0;
    }

    1;

}    # --- END lib/Elevate/Blockers/Databases.pm

{    # --- BEGIN lib/Elevate/Blockers/DiskSpace.pm

    package Elevate::Blockers::DiskSpace;

    use cPstrict;

    use Cpanel::SafeRun::Simple ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use constant K   => 1;
    use constant MEG => 1_024 * K;
    use constant GIG => 1_024 * MEG;

    sub check ($self) {    # $self is a cpev object here
        my $ok = _disk_space_check($self);
        $self->has_blocker(q[disk space issue]) unless $ok;

        return $ok;
    }

    sub _disk_space_check ($self) {

        my $need_space = {
            '/boot'             => 120 * MEG,
            '/usr/local/cpanel' => 1.5 * GIG,    #
            '/var/lib'          => 5 * GIG,
        };

        my @keys = ( sort keys %$need_space );

        my @df_cmd = ( qw{/usr/bin/df -k}, @keys );
        my $cmd    = join( ' ', @df_cmd );

        my $result = Cpanel::SafeRun::Simple::saferunnoerror(@df_cmd) // '';
        die qq[Fail checking disk space using: $cmd\n] if $?;

        my ( $header, @out ) = split( "\n", $result );

        if ( scalar @out != scalar @keys ) {
            my $count_keys = scalar @keys;
            my $count_out  = scalar @out;
            die qq[Fail: Cannot parse df output from: $cmd\n] . "# expected $count_keys lines ; got $count_out lines\n" . join( "\n", @out ) . "\n";
        }

        my @errors;

        my $ix = 0;
        foreach my $line (@out) {
            my $key = $keys[ $ix++ ];
            my ( undef, undef, undef, $available ) = split( /\s+/, $line );

            my $need = $need_space->{$key};

            next if $available > $need;

            my $str;
            if ( $need / GIG > 1 ) {
                $str = sprintf( "- $key needs %2.2f G => available %2.2f G", $need / GIG, $available / GIG );
            }
            else {
                $str = sprintf( "- $key needs %d M => available %d M", $need / MEG, $available / MEG );
            }

            push @errors, $str;
        }

        return 1 unless @errors;

        my $details = join( "\n", @errors );

        my $pretty_distro_name = $self->upgrade_to_pretty_name();

        my $error = <<"EOS";
** Warning **: your system does not have enough disk space available to update to $pretty_distro_name

$details
EOS

        warn $error . "\n";

        return 0;    # error
    }

    1;

}    # --- END lib/Elevate/Blockers/DiskSpace.pm

{    # --- BEGIN lib/Elevate/Blockers/Distros.pm

    package Elevate::Blockers::Distros;

    use cPstrict;

    use Cpanel::OS ();

    use constant MINIMUM_CENTOS_7_SUPPORTED => 9;

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {

        my @checks = qw{
          _blocker_is_non_centos7
          _blocker_is_old_centos7
          _blocker_is_experimental_os
        };

        foreach my $name (@checks) {
            my $blocker = $self->can($name)->($self);
            return $blocker if $blocker;
        }

        return 0;
    }

    sub _blocker_is_non_centos7 ($self) {
        unless ( Cpanel::OS::major() == 7 && Cpanel::OS::distro() eq 'centos' ) {
            my $pretty_distro_name = $self->upgrade_to_pretty_name();
            return $self->has_blocker(qq[This script is only designed to upgrade CentOS 7 to $pretty_distro_name.]);
        }

        return 0;
    }

    sub _blocker_is_old_centos7 ($self) {
        if ( Cpanel::OS::minor() < MINIMUM_CENTOS_7_SUPPORTED ) {
            my $pretty_distro_name = $self->upgrade_to_pretty_name();
            return $self->has_blocker(
                sprintf(
                    'You need to run CentOS 7.%s and later to upgrade %s. You are currently using %s',    #
                    MINIMUM_CENTOS_7_SUPPORTED, $pretty_distro_name, Cpanel::OS::display_name()           #
                )
            );
        }

        return 0;
    }

    sub _blocker_is_experimental_os ($self) {
        if ( -e '/var/cpanel/caches/Cpanel-OS.custom' ) {
            return $self->has_blocker('Experimental OS detected. This script only supports CentOS 7 upgrades');
        }

        return 0;
    }

    sub bail_out_on_inappropriate_distro () {

        if ( !( eval { Cpanel::OS::can_be_elevated() } // ( Cpanel::OS::distro() eq 'centos' && Cpanel::OS::major() == 7 ) ) ) {
            FATAL(qq[This script is designed to only run on CentOS 7 servers.\n]);
            exit 1;
        }

        return;
    }

    1;

}    # --- END lib/Elevate/Blockers/Distros.pm

{    # --- BEGIN lib/Elevate/Blockers/DNS.pm

    package Elevate::Blockers::DNS;

    use cPstrict;

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {

        return $self->_blocker_non_bind_powerdns;
    }

    sub _blocker_non_bind_powerdns ( $self, $nameserver = '' ) {

        if ( $nameserver eq 'nsd' or $nameserver eq 'mydns' ) {
            my $pretty_distro_name = $self->upgrade_to_pretty_name();
            return $self->has_blocker( <<~"EOS");
        $pretty_distro_name only supports bind or powerdns. We suggest you switch to powerdns.
        Before upgrading, we suggest you run: /scripts/setupnameserver powerdns.
        EOS
        }

        return 0;
    }

    1;

}    # --- END lib/Elevate/Blockers/DNS.pm

{    # --- BEGIN lib/Elevate/Blockers/EA4.pm

    package Elevate::Blockers::EA4;

    use cPstrict;

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use Cpanel::JSON ();

    sub check ($self) {

        return $self->_blocker_ea4_profile;
    }

    sub _blocker_ea4_profile ($self) {

        my $pretty_distro_name = $self->upgrade_to_pretty_name();

        INFO("Checking EasyApache profile compatibility with $pretty_distro_name.");

        return unless $self->cpev->component('EA4')->backup;          # _backup_ea4_profile();
        my $stash        = cpev::read_stage_file();                   # FIXME - move it to a function
        my $dropped_pkgs = $stash->{'ea4'}->{'dropped_pkgs'} // {};
        return unless scalar keys $dropped_pkgs->%*;

        my @incompatible_packages;
        foreach my $pkg ( sort keys $dropped_pkgs->%* ) {
            my $type = $dropped_pkgs->{$pkg} // '';
            next if $type eq 'exp';                          # use of experimental packages is a non blocker
            next if $pkg =~ m/^ea-openssl(?:11)?-devel$/;    # ignore these packages, as they can be orphans
            push @incompatible_packages, $pkg;
        }

        return unless @incompatible_packages;

        my $list = join( "\n", map { "- $_" } @incompatible_packages );

        return $self->has_blocker( <<~"EOS" );
    One or more EasyApache 4 package(s) are not compatible with $pretty_distro_name.
    Please remove these packages before continuing the update.
    $list
    EOS
    }

    1;

}    # --- END lib/Elevate/Blockers/EA4.pm

{    # --- BEGIN lib/Elevate/Blockers/ElevateScript.pm

    package Elevate::Blockers::ElevateScript;

    use cPstrict;

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {

        $self->_blocker_wrong_location;
        $self->_is_up_to_date;

        return;
    }

    sub _blocker_wrong_location ($self) {

        my $running_from = Cwd::abs_path($0) // '';

        return 0
          if $running_from eq '/scripts/elevate-cpanel'
          || $running_from eq '/usr/local/cpanel/scripts/elevate-cpanel';

        return $self->has_blocker( <<~'EOS');
        The script is not installed to the correct directory.
        Please install it to /scripts/elevate-cpanel and run it again.
        EOS

        return 0;
    }

    sub _is_up_to_date ($self) {    # $self is a cpev object here

        return if $self->getopt('skip-elevate-version-check');

        my ( $should_block, $blocker_text ) = $self->cpev->script->is_out_of_date();
        return unless $should_block;
        $blocker_text //= '';

        return $self->has_blocker( <<~"EOS");
    $blocker_text

    Pass the --skip-elevate-version-check flag to skip this check.
    EOS
    }

    1;

}    # --- END lib/Elevate/Blockers/ElevateScript.pm

{    # --- BEGIN lib/Elevate/Blockers/Grub2.pm

    package Elevate::Blockers::Grub2;

    use cPstrict;

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use constant {
        GRUB2_WORKAROUND_NONE      => 0,
        GRUB2_WORKAROUND_OLD       => 1,
        GRUB2_WORKAROUND_NEW       => 2,
        GRUB2_WORKAROUND_UNCERTAIN => -1,
    };

    sub GRUB2_PREFIX_DEBIAN { return '/boot/grub' }
    sub GRUB2_PREFIX_RHEL   { return '/boot/grub2' }

    sub check ($self) {
        my $ok = 1;
        $ok = 0 unless $self->_blocker_grub2_workaround;
        $ok = 0 unless $self->_blocker_blscfg;
        return $ok;
    }

    sub _blocker_grub2_workaround ($self) {
        my $state = _grub2_workaround_state();
        if ( $state == GRUB2_WORKAROUND_OLD ) {
            my ( $deb, $rhel ) = ( GRUB2_PREFIX_DEBIAN, GRUB2_PREFIX_RHEL );
            WARN( <<~EOS );
        $deb/grub.cfg is currently a symlink to $rhel/grub.cfg. Your provider
        may have added this to support booting your server using their own
        instance of the GRUB2 bootloader, one which looks for its
        configuration, boot entries, and modules in a different location from
        where your operating system stores this data. In order to allow the
        process to complete successfully, the upgrade process will rename the
        current $deb directory, re-create $deb as a symlink to $rhel,
        and then copy as much of the old $deb into $rhel as possible.
        EOS
            cpev::update_stage_file( { 'grub2_workaround' => { 'needs_workaround_update' => 1 } } ) if !$self->is_check_mode();    # don't update stage file if this is just a check
        }
        elsif ( $state == GRUB2_WORKAROUND_UNCERTAIN ) {

            return $self->has_blocker( <<~EOS );
        The configuration of the GRUB2 bootloader does not match the
        expectations of this script. For more information, see the output of
        the script when run at the console:

        /scripts/elevate-cpanel --check

        If your GRUB2 configuration has not been customized, consider reporting
        this limitation to https://github.com/cpanel/elevate/issues
        EOS
        }

        return 0;
    }

    sub _blocker_blscfg ($self) {

        my $grub_enable_blscfg = _parse_shell_variable( Elevate::Constants::DEFAULT_GRUB_FILE, 'GRUB_ENABLE_BLSCFG' );

        return $self->has_blocker( <<~EOS ) if defined $grub_enable_blscfg && $grub_enable_blscfg ne 'true';
    Disabling the BLS boot entry format prevents the resulting system from
    adding kernel updates to any boot loader configuration, because the old
    utility responsible for maintaining native GRUB2 boot loader entries was
    removed and replaced with a wrapper around the new utility, which only
    understands BLS format. This means that the old kernel will be used on
    reboot, unless the GRUB2 configuration file is manually edited to load the
    new kernel. Furthermore, after a few kernel updates, the DNF package
    manager may begin to remove old kernels, including the one still used in
    the configuration file. If that happens, the system will fail to come back
    after a subsequent reboot.

    The safe option is to remove the following line in /etc/default/grub:

    GRUB_ENABLE_BLSCFG=false

    or to change it so that it is set to "true" instead.
    EOS

        return 0;
    }

    sub _parse_shell_variable ( $path, $varname ) {

        my ( undef, $dir, $file ) = File::Spec->splitpath($path);
        $dir = File::Spec->canonpath($dir);

        my $bash_sr = Cpanel::SafeRun::Object->new(
            program => Cpanel::Binaries::path('bash'),
            args    => [
                '--restricted',
                '-c',
                qq(set -ux ; [ "x\$PWD" = "x$dir" ] || exit 72 ; source $file ; echo "\$$varname"),
            ],
            before_exec => sub {
                chdir $dir;
                Cpanel::AccessIds::SetUids::setuids('nobody');
            },
        );

        return undef if $bash_sr->CHILD_ERROR && $bash_sr->error_code == 127;
        $bash_sr->die_if_error();    # bail out if something else went wrong

        my $value = $bash_sr->stdout;
        chomp $value;
        return $value;
    }

    sub _grub2_workaround_state () {

        return GRUB2_WORKAROUND_NONE if !-e GRUB2_PREFIX_DEBIAN;

        if ( -l GRUB2_PREFIX_DEBIAN ) {
            my $dest = Cwd::realpath(GRUB2_PREFIX_DEBIAN);
            if ( !defined($dest) ) {
                ERROR( GRUB2_PREFIX_DEBIAN . " is a symlink but realpath() failed: $!" ) unless defined($dest);
                return GRUB2_WORKAROUND_UNCERTAIN;
            }

            if ( $dest eq GRUB2_PREFIX_RHEL ) {
                return GRUB2_WORKAROUND_NEW if -d $dest;
                ERROR( GRUB2_PREFIX_DEBIAN . " does not ultimately link to /boot/grub2." );
                return GRUB2_WORKAROUND_UNCERTAIN;    # ...unless /boot/grub2 isn't a directory.
            }
        }

        elsif ( !-d GRUB2_PREFIX_DEBIAN ) {
            ERROR( GRUB2_PREFIX_DEBIAN . " is neither symlink nor directory." );
            return GRUB2_WORKAROUND_UNCERTAIN;
        }

        my ( $grub_cfg, $grub2_cfg ) = map { $_ . "/grub.cfg" } ( GRUB2_PREFIX_DEBIAN, GRUB2_PREFIX_RHEL );

        return GRUB2_WORKAROUND_NONE if !-e $grub_cfg;

        if ( -l $grub_cfg ) {
            my $dest_cfg = Cwd::realpath($grub_cfg);
            if ( !defined($dest_cfg) ) {
                ERROR("$grub_cfg is a symlink but realpath() failed: $!");
                return GRUB2_WORKAROUND_UNCERTAIN;
            }

            if ( $dest_cfg eq $grub2_cfg ) {
                return GRUB2_WORKAROUND_OLD if -f $dest_cfg;
                ERROR("$dest_cfg is not a regular file.");
                return GRUB2_WORKAROUND_UNCERTAIN;    # ...unless /boot/grub2/grub.cfg isn't a regular file.
            }
        }

        ERROR("$grub_cfg exists but is not a symlink which ultimately links to $grub2_cfg.");
        return GRUB2_WORKAROUND_UNCERTAIN;
    }

    1;

}    # --- END lib/Elevate/Blockers/Grub2.pm

{    # --- BEGIN lib/Elevate/Blockers/IsContainer.pm

    package Elevate::Blockers::IsContainer;

    use cPstrict;

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {    # $self is a cpev object here
        if ( _is_container_envtype() ) {
            return $self->has_blocker("cPanel thinks that this is a container-like environment, which this script cannot support at this time.");
        }
        return 0;
    }

    sub _is_container_envtype () {
        require Cpanel::OSSys::Env;
        my $envtype = Cpanel::OSSys::Env::get_envtype();

        return scalar grep { $envtype eq $_ } qw(
          virtuozzo
          vzcontainer
          lxc
          virtualiron
          vserver
        );
    }

    1;

}    # --- END lib/Elevate/Blockers/IsContainer.pm

{    # --- BEGIN lib/Elevate/Blockers/JetBackup.pm

    package Elevate::Blockers::JetBackup;

    use cPstrict;

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    use Cpanel::Pkgr ();
    use Cwd          ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {

        return $self->_blocker_old_jetbackup;
    }

    sub _blocker_old_jetbackup ($self) {

        return 0 unless $self->_use_jetbackup4_or_earlier();

        my $pretty_distro_name = $self->upgrade_to_pretty_name();

        return $self->has_blocker( <<~"END" );
    $pretty_distro_name does not support JetBackup prior to version 5.
    Please upgrade JetBackup before elevate.
    END

        return 0;
    }

    sub _use_jetbackup4_or_earlier ($self) {
        return unless Cpanel::Pkgr::is_installed('jetbackup');
        my $v = Cpanel::Pkgr::get_package_version("jetbackup");

        if ( defined $v && $v =~ qr{^[1-4]\b} ) {
            WARN("JetBackup version $v currently installed.");
            return 1;
        }

        return;
    }

    1;

}    # --- END lib/Elevate/Blockers/JetBackup.pm

{    # --- BEGIN lib/Elevate/Blockers/NICs.pm

    package Elevate::Blockers::NICs;

    use cPstrict;

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use constant SBIN_IP => q[/sbin/ip];

    sub check ($self) {
        return $self->_blocker_bad_nics_naming;
    }

    sub _blocker_bad_nics_naming ($self) {
        return $self->has_blocker( q[Missing ] . SBIN_IP . ' binary' ) unless -x SBIN_IP;
        my @eths = _get_nics();
        if ( @eths >= 2 ) {
            return $self->has_blocker( <<~'EOS');
        Your machine has multiple network interface cards (NICs) using kernel-names (ethX).
        Since the upgrade process cannot guarantee their stability after upgrade, you cannot upgrade.

        Please provide those interfaces new names before continuing the update.
        EOS
        }

        return 0;
    }

    sub _get_nics {
        my $ip_info = Cpanel::SafeRun::Errors::saferunnoerror( SBIN_IP, 'addr' ) // '';

        my @eths;
        foreach my $line ( split /\n/xms, $ip_info ) {
            $line =~ /^[0-9]+: \s (eth[0-9]):/xms
              or next;

            my $eth   = $1;
            my $value = readlink "/sys/class/net/$eth"
              or next;

            $value =~ m{/virtual/}xms
              and next;

            push @eths, $eth;
        }

        return @eths;
    }

    1;

}    # --- END lib/Elevate/Blockers/NICs.pm

{    # --- BEGIN lib/Elevate/Blockers/OVH.pm

    package Elevate::Blockers::OVH;

    use cPstrict;

    use Cpanel::Version::Tiny ();
    use Cpanel::Update::Tiers ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use constant OVH_MONITORING_TOUCH_FILE => q[/var/cpanel/acknowledge_ovh_monitoring_for_elevate];

    sub check ($self) {

        return 0 unless $self->__is_ovh();

        my $touch_file = OVH_MONITORING_TOUCH_FILE;

        return 0 if -e $touch_file;

        my $message = <<~"EOS";
    We have detected that your server is hosted by "OVH SA" company.

    Before continuing the elevation process, you should disable the "proactive monitoring" provided by OVH.
    When using "proactive monitoring" your server could incorrectly boot in rescue mode during the elevate process.

    Once you have disabled the monitoring system (or confirm this message does not apply to you),
    please touch that file and continue the elevation pricess.

    > touch $touch_file

    You can read more about this issue:
    URL: https://github.com/cpanel/elevate/issues/176
    OVH Monitoring Documentation: https://support.us.ovhcloud.com/hc/en-us/articles/115001821044-Overview-of-OVHcloud-Monitoring-on-Dedicated-Servers
    EOS

        return $self->has_blocker($message);
    }

    sub __is_ovh ($self) {
        return 1 if -e q[/root/.ovhrc];

        my @ip_rules = qw{
          5.39.0.0/17
          5.135.0.0/16
          5.196.0.0/16
          8.7.244.0/24
          8.18.128.0/24
          8.18.172.0/24
          8.20.110.0/24
          8.21.41.0/24
          8.24.8.0/21
          8.26.94.0/24
          8.29.224.0/24
          8.30.208.0/21
          8.33.96.0/21
          8.33.128.0/21
          8.33.136.0/23
          15.204.0.0/16
          15.235.0.0/16
          23.92.224.0/19
          37.59.0.0/16
          37.60.48.0/20
          37.187.0.0/16
          45.92.60.0/22
          46.105.0.0/16
          46.244.32.0/20
          51.38.0.0/16
          51.68.0.0/16
          51.75.0.0/16
          51.77.0.0/16
          51.79.0.0/16
          51.81.0.0/16
          51.83.0.0/16
          51.89.0.0/16
          51.91.0.0/16
          51.161.0.0/16
          51.178.0.0/16
          51.195.0.0/16
          51.210.0.0/16
          51.222.0.0/16
          51.254.0.0/15
          54.36.0.0/14
          57.128.0.0/17
          57.128.128.0/18
          62.3.18.0/24
          66.70.128.0/17
          79.137.0.0/17
          87.98.128.0/17
          91.90.88.0/21
          91.121.0.0/16
          91.134.0.0/16
          92.222.0.0/16
          92.246.224.0/19
          94.23.0.0/16
          103.5.12.0/22
          107.189.64.0/18
          109.190.0.0/16
          135.125.0.0/16
          135.148.0.0/16
          137.74.0.0/16
          139.99.0.0/16
          141.94.0.0/15
          142.4.192.0/19
          142.44.128.0/17
          144.2.32.0/19
          144.217.0.0/16
          145.239.0.0/16
          146.59.0.0/16
          147.135.0.0/16
          148.113.0.0/18
          148.113.128.0/17
          149.56.0.0/16
          149.202.0.0/16
          151.80.0.0/16
          151.127.0.0/16
          152.228.128.0/17
          158.69.0.0/16
          162.19.0.0/16
          164.132.0.0/16
          167.114.0.0/16
          172.83.201.0/24
          176.31.0.0/16
          178.32.0.0/15
          185.12.32.0/23
          185.15.68.0/22
          185.45.160.0/22
          185.228.96.0/22
          188.165.0.0/16
          192.95.0.0/18
          192.99.0.0/16
          192.240.152.0/21
          193.31.62.0/24
          193.43.104.0/24
          193.70.0.0/17
          195.110.30.0/23
          195.246.232.0/23
          198.27.64.0/18
          198.50.128.0/17
          198.100.144.0/20
          198.244.128.0/17
          198.245.48.0/20
          209.126.71.0/24
          213.32.0.0/17
          213.186.32.0/19
          213.251.128.0/18
          217.182.0.0/16
        };

        require Net::CIDR;

        my @cidr_list;
        foreach my $rule (@ip_rules) {
            if ( Net::CIDR::cidrvalidate($rule) ) {
                @cidr_list = Net::CIDR::cidradd( $rule, @cidr_list );
            }
            else {
                WARN("Invalid CIDR rule '$rule'");
            }
        }

        require Cpanel::DIp::MainIP;
        require Cpanel::NAT;

        my $public_ip = Cpanel::NAT::get_public_ip( Cpanel::DIp::MainIP::getmainip() );
        return 1 if eval { Net::CIDR::cidrlookup( $public_ip, @cidr_list ) };

        return 0;
    }

    1;

}    # --- END lib/Elevate/Blockers/OVH.pm

{    # --- BEGIN lib/Elevate/Blockers/Repositories.pm

    package Elevate::Blockers::Repositories;

    use cPstrict;

    use Cpanel::OS ();

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use constant DISABLE_MYSQL_YUM_REPOS => qw{
      Mysql57.repo
      Mysql80.repo

      MariaDB102.repo
      MariaDB103.repo
      MariaDB105.repo
      MariaDB106.repo

      mysql-community.repo
    };

    use constant VETTED_MYSQL_YUM_REPO_IDS => qw{
      mysql-cluster-7.5-community
      mysql-cluster-7.5-community
      mysql-cluster-7.5-community-source
      mysql-cluster-7.5-community-source
      mysql-cluster-7.6-community
      mysql-cluster-7.6-community
      mysql-cluster-7.6-community-source
      mysql-cluster-7.6-community-source
      mysql-cluster-8.0-community
      mysql-cluster-8.0-community-debuginfo
      mysql-cluster-8.0-community-source
      mysql-connectors-community
      mysql-connectors-community
      mysql-connectors-community-debuginfo
      mysql-connectors-community-source
      mysql-connectors-community-source
      mysql-tools-community
      mysql-tools-community
      mysql-tools-community-debuginfo
      mysql-tools-community-source
      mysql-tools-community-source
      mysql-tools-preview
      mysql-tools-preview
      mysql-tools-preview-source
      mysql-tools-preview-source
      mysql55-community
      mysql55-community-source
      mysql56-community
      mysql56-community-source
      mysql57-community
      mysql57-community
      mysql57-community-source
      mysql57-community-source
      mysql80-community
      mysql80-community
      mysql80-community-debuginfo
      mysql80-community-source
      mysql80-community-source
      MariaDB102
      MariaDB103
      MariaDB105
      MariaDB106
    };

    use constant VETTED_YUM_REPO => qw{
      base
      updates
      extras
      centosplus
      cr
      c7-media
      fasttrack
      EA4
      epel-testing
      epel
      centos-kernel
      centos-kernel-experimental
      wp-toolkit-cpanel
      wp-toolkit-thirdparties
      cpanel-addons-production-feed
      cpanel-plugins
      elasticsearch
      cp-dev-tools
      elevate
      elevate-source
      influxdb
      droplet-agent
      kernelcare
      imunify360-rollout-1
      imunify360-rollout-2
      imunify360-rollout-3
      imunify360-rollout-4
      imunify360
      imunify360-ea-php-hardened
    }, VETTED_MYSQL_YUM_REPO_IDS;

    sub check ($self) {
        my $ok = 1;
        $ok = 0 unless $self->_blocker_system_update;
        $ok = 0 unless $self->_blocker_invalid_yum_repos;
        $ok = 0 unless $self->_blocker_unstable_yum;

        return $ok;
    }

    sub _blocker_invalid_yum_repos ($self) {
        my $status_hr = $self->_check_yum_repos();
        if ( _yum_status_hr_contains_blocker($status_hr) ) {
            my $msg = '';
            if ( $status_hr->{'INVALID_SYNTAX'} ) {
                $msg .= <<~'EOS';
            One or more enabled YUM repo are using invalid syntax.
            '\$' variables behave differently in repo files between RedHat 7 and RedHat 8.
            RedHat 7 interpolates '\$' variable whereas RedHat 8 does not.

            Please fix the files before continuing the update.
            EOS
            }
            if ( $status_hr->{'USE_RPMS_FROM_UNVETTED_REPO'} ) {
                $msg .= <<~'EOS';
            One or more enabled YUM repo are currently unsupported and have installed packages.
            You should disable these repositories and remove packages installed from them
            before continuing the update.

            Consider reporting this limitation to https://github.com/cpanel/elevate/issues
            EOS
            }

            if ( !Elevate::Blockers::Base->is_check_mode() ) {    # autofix when --check is not used
                $self->_autofix_yum_repos();

                $status_hr = $self->_check_yum_repos();
            }

            $self->has_blocker( $msg, repos => $self->{_yum_repos_unsupported_with_packages} ) if _yum_status_hr_contains_blocker($status_hr);
        }

        return 0;
    }

    sub _blocker_unstable_yum ($self) {
        $self->has_blocker(q[yum is not stable]) unless $self->_yum_is_stable();

        return 0;
    }

    sub _blocker_system_update ($self) {
        return 0 if $self->_system_update_check();
        return $self->has_blocker(q[System is not up to date]);
    }

    sub _yum_status_hr_contains_blocker ($status_hr) {
        return 0 if ref $status_hr ne 'HASH' || !scalar keys( %{$status_hr} );

        my @blockers = qw{INVALID_SYNTAX USE_RPMS_FROM_UNVETTED_REPO};
        foreach my $blocked (@blockers) {
            return 1 if $status_hr->{$blocked};
        }
        return 0;
    }

    sub _yum_is_stable ($self) {
        my $errors = Cpanel::SafeRun::Errors::saferunonlyerrors(qw{/usr/bin/yum makecache});
        if ( $errors =~ m/\S/ms ) {
            ERROR('yum appears to be unstable. Please address this before upgrading');
            ERROR($errors);

            return 0;
        }

        if ( opendir( my $dfh, '/var/lib/yum' ) ) {
            my @transactions = grep { m/^transaction-all\./ } readdir $dfh;
            if (@transactions) {
                ERROR('There are unfinished yum transactions remaining. Please address these before upgrading. The tool `yum-complete-transaction` may help you with this task.');
                return 0;
            }
        }
        else {
            ERROR(qq{Could not read directory '/var/lib/yum': $!});
            return 0;
        }

        return 1;
    }

    sub _check_yum_repos ($self) {

        $self->{_yum_repos_path_using_invalid_syntax} = [];
        $self->{_yum_repos_to_disable}                = [];
        $self->{_yum_repos_unsupported_with_packages} = [];

        my %vetted = map { $_ => 1 } VETTED_YUM_REPO;

        my $repo_dir = Elevate::Constants::YUM_REPOS_D;

        my %status;
        opendir( my $dh, $repo_dir ) or do {
            ERROR("Cannot read directory $repo_dir - $!");
            return;
        };
        foreach my $f ( readdir($dh) ) {
            next unless $f =~ m{\.repo$};
            my $path = "${repo_dir}/$f";

            next unless -f $path;

            my $txt = eval { File::Slurper::read_text($path) };

            next unless length $txt;
            my @lines = split( qr/\n/, $txt );
            my $current_repo_name;
            my $current_repo_enabled          = 1;
            my $current_repo_use_valid_syntax = 1;

            my $check_last_known_repo = sub {
                return unless length $current_repo_name;
                return unless $current_repo_enabled;

                my $is_vetted = $vetted{$current_repo_name} || $vetted{ lc $current_repo_name };

                if ( !$is_vetted ) {
                    $status{'UNVETTED'} = 1;
                    if ( my $total_pkg = scalar cpev::get_installed_rpms_in_repo($current_repo_name) ) {    # FIXME
                        ERROR(
                            sprintf(
                                "%d package(s) installed from unsupported YUM repo '%s' from %s",
                                $total_pkg,
                                $current_repo_name, $path
                            )
                        );
                        push( $self->{_yum_repos_unsupported_with_packages}->@*, $current_repo_name );
                        $status{'USE_RPMS_FROM_UNVETTED_REPO'} = 1;
                    }
                    else {
                        INFO( sprintf( "Unsupported YUM repo enabled '%s' without packages installed from %s, these will be disabled before ELevation", $current_repo_name, $path ) );

                        push( $self->{_yum_repos_to_disable}->@*, $current_repo_name );
                        $status{'HAS_UNUSED_REPO_ENABLED'} = 1;
                    }
                }
                elsif ( !$current_repo_use_valid_syntax ) {
                    WARN( sprintf( "YUM repo '%s' is using unsupported '\\\$' syntax in %s", $current_repo_name, $path ) );
                    unless ( grep { $_ eq $path } $self->{_yum_repos_path_using_invalid_syntax}->@* ) {
                        push( $self->{_yum_repos_path_using_invalid_syntax}->@*, $path );
                    }
                    $status{'INVALID_SYNTAX'} = 1;
                }
                return;
            };

            foreach my $line (@lines) {
                next if $line =~ qr{^\s*\#};       # skip comments
                $line =~ s{\s*\#.+$}{};            # strip comments
                if ( $line =~ qr{^\s*\[\s*(.+)\s*\]} ) {
                    $check_last_known_repo->();

                    $current_repo_name             = $1;
                    $current_repo_enabled          = 1;    # assume enabled unless explicitely disabled
                    $current_repo_use_valid_syntax = 1;

                    next;
                }
                next unless defined $current_repo_name;

                $current_repo_enabled = 0 if $line =~ m{^\s*enabled\s*=\s*0};

                $current_repo_use_valid_syntax = 0 if $line =~ m{\\\$};
            }

            $check_last_known_repo->();
        }
        return \%status;
    }

    sub _autofix_yum_repos ($self) {

        if ( ref $self->{_yum_repos_path_using_invalid_syntax} ) {
            my @files_with_invalid_syntax = $self->{_yum_repos_path_using_invalid_syntax}->@*;

            foreach my $f (@files_with_invalid_syntax) {
                INFO( q[Fixing \$ variables in repo file: ] . $f );
                Cpanel::SafeRun::Simple::saferunnoerror( $^X, '-pi', '-e', 's{\\\\\$}{\$}g', $f );
            }
        }

        if ( ref $self->{_yum_repos_to_disable} ) {
            my @repos_to_disable = $self->{_yum_repos_to_disable}->@*;
            foreach my $repo (@repos_to_disable) {
                INFO(qq[Disabling unused yum repository: $repo]);
                Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/bin/yum-config-manager --disable}, $repo );
            }
        }

        return;
    }

    sub _system_update_check ($self) {

        INFO("Checking if your system is up to date: ");
        $self->ssystem(qw{/usr/bin/yum clean all});

        my $out = $self->ssystem_capture_output(qw{/usr/bin/yum check-update -q});

        if ( $out->{status} != 0 ) {

            WARN("Your system is not up to date please run: /usr/bin/yum update");

            my $is_blocker;
            my $output = $out->{stdout} // [];
            foreach my $line (@$output) {
                next if $line =~ qr{^\s+$};
                next if $line =~ qr{^kernel};    # do not block if we need to update kernel packages
                $is_blocker = 1;
                last;
            }

            return if $is_blocker;
        }

        INFO("Checking /scripts/sysup");
        if ( $self->ssystem("/scripts/sysup") != 0 ) {
            WARN("/scripts/sysup failed, please fix it and rerun it before upgrading.");
            return;
        }

        return 1;
    }

    1;

}    # --- END lib/Elevate/Blockers/Repositories.pm

{    # --- BEGIN lib/Elevate/Blockers/SSH.pm

    package Elevate::Blockers::SSH;

    use cPstrict;

    use Elevate::Constants ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    use Cwd           ();
    use File::Slurper ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {

        return $self->_blocker_invalid_ssh_config;
    }

    sub _blocker_invalid_ssh_config ($self) {
        return $self->has_blocker(q[Issue with sshd configuration]) unless $self->_sshd_setup();
        return 0;
    }

    sub _sshd_setup ($self) {
        my $sshd_config = q[/etc/ssh/sshd_config];

        my $setup = eval { File::Slurper::read_binary($sshd_config) } // '';

        if ( $setup !~ m{^\s*PermitRootLogin\b}m ) {
            ERROR( <<~"EOS" );
        OpenSSH configuration file does not explicitly state the option PermitRootLogin in sshd_config file, which will default in RHEL8 to "prohibit-password".
        Please set the 'PermitRootLogin' value in $sshd_config before upgrading.
        EOS

            return 0;
        }

        return 1;
    }

    1;

}    # --- END lib/Elevate/Blockers/SSH.pm

{    # --- BEGIN lib/Elevate/Blockers/WHM.pm

    package Elevate::Blockers::WHM;

    use cPstrict;

    use Elevate::Constants ();
    use Elevate::Notify    ();

    use Cpanel::Version::Tiny ();
    use Cpanel::Update::Tiers ();
    use Cpanel::Pkgr          ();

    # use Elevate::Blockers::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Blockers::Base); }

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub check ($self) {

        my $ok = 1;

        $ok = 0 unless $self->_blocker_is_missing_cpanel_whm;
        $ok = 0 unless $self->_blocker_is_invalid_cpanel_whm;
        $ok = 0 unless $self->_blocker_is_newer_than_lts;
        $ok = 0 unless $self->_blocker_cpanel_needs_update;
        $ok = 0 unless $self->_blocker_is_sandbox;
        $ok = 0 unless $self->_blocker_is_calendar_installed;

        return $ok;
    }

    sub _blocker_is_missing_cpanel_whm ($self) {
        if ( !-x q[/usr/local/cpanel/cpanel] ) {
            return $self->has_blocker('This script is only designed to work with cPanel & WHM installs. cPanel & WHM do not appear to be present on your system.');
        }

        return 0;
    }

    sub _blocker_is_invalid_cpanel_whm ($self) {
        if ( !$Cpanel::Version::Tiny::major_version ) {
            return $self->has_blocker('Invalid cPanel & WHM major_version.');
        }

        return 0;
    }

    sub _blocker_is_newer_than_lts ($self) {
        if ( $Cpanel::Version::Tiny::major_version <= Elevate::Constants::MINIMUM_LTS_SUPPORTED - 2 ) {
            my $pretty_distro_name = $self->upgrade_to_pretty_name();
            return $self->has_blocker( sprintf( "This version %s does not support upgrades to %s. Please upgrade to cPanel version %s or better.", $Cpanel::Version::Tiny::VERSION_BUILD, $pretty_distro_name, Elevate::Constants::MINIMUM_LTS_SUPPORTED ) );
        }

        return 0;
    }

    sub _blocker_cpanel_needs_update ($self) {
        if ( !$self->getopt('skip-cpanel-version-check') ) {
            my $tiers_obj = Cpanel::Update::Tiers->new( logger => Log::Log4perl->get_logger(__PACKAGE__) );
            if ( !grep { Cpanel::Version::Compare::compare( $Cpanel::Version::Tiny::VERSION_BUILD, '==', $_ ) } $tiers_obj->get_flattened_hash()->@{qw/edge current release stable lts/} ) {
                my $hint = '';
                $hint = q[hint: You can skip this check using --skip-cpanel-version-check] if $Cpanel::Version::Tiny::VERSION_BUILD =~ 9999;
                return $self->has_blocker( <<~"EOS" );
            This installation of cPanel ($Cpanel::Version::Tiny::VERSION_BUILD) does not appear to be up to date.
            Please upgrade cPanel to a most recent version. $hint
            EOS
            }
        }
        else {
            Elevate::Notify::warn_skip_version_check();
        }

        return 0;
    }

    sub _blocker_is_sandbox ($self) {
        if ( -e q[/var/cpanel/dev_sandbox] ) {
            return $self->has_blocker('Cannot elevate a sandbox...');
        }

        return 0;
    }

    sub _blocker_is_calendar_installed ($self) {
        if ( Cpanel::Pkgr::is_installed('cpanel-ccs-calendarserver') ) {
            return $self->has_blocker( <<~'EOS');
        You have the cPanel Calendar Server installed. Upgrades with this server in place are not supported.
        Removal of this server can lead to data loss.
        EOS
        }

        return 0;
    }

    1;

}    # --- END lib/Elevate/Blockers/WHM.pm

{    # --- BEGIN lib/Elevate/Components/ArchRPMs.pm

    package Elevate::Components::ArchRPMs;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        my @installed_arch_cpanel_plugins;

        my $installed    = cpev::yum_list();
        my @cpanel_repos = grep { m/^cpanel-/ } keys %$installed;
        foreach my $repo (@cpanel_repos) {
            push @installed_arch_cpanel_plugins, map { $_->{'package'} } $installed->{$repo}->@*;
        }

        return unless @installed_arch_cpanel_plugins;

        cpev::update_stage_file( { restore => { yum => \@installed_arch_cpanel_plugins } } );

        return;
    }

    sub post_leapp ($self) {

        my $stash            = cpev::read_stage_file();
        my $yum_arch_plugins = $stash->{'restore'}->{'yum'} // [];
        return unless scalar @$yum_arch_plugins;

        INFO('Restoring cPanel yum-based-plugins');
        $self->ssystem( qw{ /usr/bin/dnf -y reinstall }, @$yum_arch_plugins );

        return;
    }

    1;

}    # --- END lib/Elevate/Components/ArchRPMs.pm

{    # --- BEGIN lib/Elevate/Components/Base.pm

    package Elevate::Components::Base;

    use cPstrict;

    use Simple::Accessor qw(
      cpev
    );

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    BEGIN {
        my @_DELEGATE_TO_CPEV = qw{
          getopt
          update_stage_file
          upgrade_to_rocky
          upgrade_to_pretty_name
          tmp_dir
          ssystem
          ssystem_and_die
          ssystem_capture_output
          remove_rpms_from_repos
        };

        foreach my $subname (@_DELEGATE_TO_CPEV) {
            no strict 'refs';
            *$subname = sub ( $self, @args ) {
                my $cpev = $self->cpev;
                my $sub  = $cpev->can($subname) or die qq[cpev does not support $subname];
                return $sub->( $cpev, @args );
            }
        }
    }

    sub run_once ( $self, $subname ) {

        my $cpev     = $self->cpev;
        my $run_once = $cpev->can('run_once') or die qq[cpev does not support 'run_once'];

        my $label = ref($self) . "::$subname";

        my $sub = $self->can($subname) or die qq[$self does not support '$subname'];

        my $code = sub {
            return $sub->($self);
        };

        return $run_once->( $cpev, $label, $code );
    }

    1;

}    # --- END lib/Elevate/Components/Base.pm

{    # --- BEGIN lib/Elevate/Components/DigitalOcean.pm

    package Elevate::Components::DigitalOcean;

    use cPstrict;

    use Cpanel::Pkgr       ();
    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        return;
    }

    sub post_leapp ($self) {

        return unless Cpanel::Pkgr::is_installed('droplet-agent');
        return unless -f '/etc/yum.repos.d/droplet-agent.repo';

        $self->ssystem(qw{/usr/bin/yum -y reinstall droplet-agent});

        return;
    }

    1;

}    # --- END lib/Elevate/Components/DigitalOcean.pm

{    # --- BEGIN lib/Elevate/Components/EA4.pm

    package Elevate::Components::EA4;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use Cpanel::JSON            ();
    use Cpanel::Pkgr            ();
    use Cpanel::SafeRun::Simple ();

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    use Elevate::Blockers ();

    sub backup ($self) {    # run by the check (should be a dry run mode)

        $self->_backup_ea4_profile;
        $self->_backup_ea_addons;

        return;
    }

    sub pre_leapp ($self) {    # run to perform the backup

        $self->run_once('_backup_ea4_profile');
        $self->run_once('_backup_ea_addons');

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_restore_ea4_profile');
        $self->run_once('_restore_ea_addons');

        return;
    }

    sub _restore_ea_addons ($self) {

        return unless cpev::read_stage_file('ea4')->{'nginx'};

        INFO("Restoring ea-nginx");

        $self->ssystem(qw{/usr/bin/rpm -e --nodeps ea-nginx});
        $self->ssystem_and_die(qw{/usr/bin/yum install -y ea-nginx});

        return;
    }

    sub _backup_ea_addons ($self) {

        if ( Cpanel::Pkgr::is_installed('ea-nginx') ) {
            cpev::update_stage_file( { ea4 => { nginx => 1 } } );
        }
        else {
            cpev::update_stage_file( { ea4 => { nginx => 0 } } );
        }

        return;
    }

    sub _backup_ea4_profile ($self) {    ## _backup_ea4_profile

        my $use_ea4 = Cpanel::Config::Httpd::is_ea4() ? 1 : 0;

        cpev::remove_from_stage_file('ea4');
        cpev::update_stage_file( { ea4 => { enable => $use_ea4 } } );

        unless ($use_ea4) {

            WARN('Skipping EA4 backup. EA4 does not appear to be enabled on this system');

            return;
        }

        my $json_path = $self->_get_ea4_profile();

        my $data = { profile => $json_path };

        my $profile = eval { Cpanel::JSON::LoadFile($json_path) } // {};
        if ( ref $profile->{os_upgrade} && ref $profile->{os_upgrade}->{dropped_pkgs} ) {
            $data->{dropped_pkgs} = $profile->{os_upgrade}->{dropped_pkgs};
        }

        cpev::update_stage_file( { ea4 => $data } );    # FIXME

        return 1;
    }

    sub _get_ea4_profile ($self) {

        my $ea_alias = $self->upgrade_to_rocky() ? 'CentOS_8' : 'AlmaLinux_8';

        my @cmd = ( '/usr/local/bin/ea_current_to_profile', "--target-os=$ea_alias" );

        my $profile_file;

        if ( Elevate::Blockers->is_check_mode() ) {

            $profile_file = $self->tmp_dir() . '/ea_profile.json';
            push @cmd, "--output=$profile_file";
        }

        my $cmd_str = join( ' ', @cmd );

        INFO("Running: $cmd_str");
        my $output = Cpanel::SafeRun::Simple::saferunnoerror(@cmd) // '';
        die qq[Unable to backup EA4 profile. Failure from $cmd_str] if $?;

        if ( !$profile_file ) {

            my @lines = split( "\n", $output );

            if ( scalar @lines == 1 ) {
                $profile_file = $lines[0];
            }
            else {
                foreach my $l ( reverse @lines ) {
                    next unless $l =~ m{^/.*\.json};
                    if ( -f $l ) {
                        $profile_file = $l;
                        last;
                    }
                }
            }
        }

        die "Unable to backup EA4 profile running: $cmd_str" unless length $profile_file && -f $profile_file && -s _;
        INFO("Backed up EA4 profile to $profile_file");

        return $profile_file;
    }

    sub _restore_ea4_profile ($self) {

        my $stash      = cpev::read_stage_file();
        my $is_enabled = $stash->{'ea4'} && $stash->{'ea4'}->{'enable'};

        unless ($is_enabled) {
            WARN('Skipping EA4 restore. EA4 does not appear to be enabled on this system.');
            return;
        }

        my $json = $stash->{'ea4'}->{'profile'};
        unless ( length $json && -f $json && -s _ ) {
            WARN('Unable to restore EA4 profile. Is EA4 enabled?');
            INFO("Profile was backed up as: $json") if length $json;
            return;
        }

        $self->ssystem( '/usr/local/bin/ea_install_profile', '--install', $json );

        if ( my $dropped_pkgs = $stash->{'ea4'}->{'dropped_pkgs'} ) {
            if ( scalar keys $dropped_pkgs->%* ) {
                my $msg = qq[One or more EasyApache 4 package(s) cannot be restored from your previous profile:\n];
                foreach my $pkg ( sort keys $dropped_pkgs->%* ) {
                    my $type = $dropped_pkgs->{$pkg} // '';
                    $msg .= sprintf( "- '%s'%s\n", $pkg, $type eq 'exp' ? ' ( package was Experimental in CentOS 7 )' : '' );
                }
                chomp $msg;
                Elevate::Notify::add_final_notification( $msg, 1 );
            }
        }

        return 1;
    }

    1;

}    # --- END lib/Elevate/Components/EA4.pm

{    # --- BEGIN lib/Elevate/Components/Grub2.pm

    package Elevate::Components::Grub2;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use Cpanel::JSON            ();
    use Cpanel::Pkgr            ();
    use Cpanel::SafeRun::Simple ();

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    use Elevate::Blockers ();

    use constant GRUB_EDITENV  => '/usr/bin/grub2-editenv';
    use constant GRUB_ENV_FILE => '/boot/grub2/grubenv';

    sub pre_leapp ($self) {

        $self->run_once('_update_grub2_workaround_if_needed');    # required part
        $self->run_once('_merge_grub_directories_if_needed');     # best-effort part

        return;
    }

    sub GRUB2_PREFIX_DEBIAN { return '/boot/grub' }     # FIXME deduplicate & move to constant
    sub GRUB2_PREFIX_RHEL   { return '/boot/grub2' }    # FIXME deduplicate & move to constant

    sub _update_grub2_workaround_if_needed ($self) {

        my $grub2_info = cpev::read_stage_file('grub2_workaround');
        return unless $grub2_info->{'needs_workaround_update'};

        my $grub_dir  = GRUB2_PREFIX_DEBIAN;
        my $grub2_dir = GRUB2_PREFIX_RHEL;

        my $grub_bak;
        if ( $grub2_info->{'backup_dir'} ) {
            $grub_bak = $grub2_info->{'backup_dir'};
        }
        else {
            $grub_bak = $grub2_info->{'backup_dir'} = $grub_dir . '-' . time;
            cpev::update_stage_file( { 'grub2_workaround' => $grub2_info } );
        }

        rename $grub_dir, $grub_bak or LOGDIE("Unable to rename $grub_dir to $grub_bak: $!");    # failure on cross-device move is a feature
        symlink $grub2_dir, $grub_dir or do {
            rename $grub_bak, $grub_dir;                                                         # undo previous change on failure
            LOGDIE("Unable to create symlink $grub_dir to point to $grub2_dir");                 # symlink() doesn't set $!
        };

        return;
    }

    sub _merge_grub_directories_if_needed ($self) {

        my $grub2_info = cpev::read_stage_file('grub2_workaround');
        return unless $grub2_info->{'needs_workaround_update'};

        my $grub_dir  = GRUB2_PREFIX_DEBIAN;
        my $grub2_dir = GRUB2_PREFIX_RHEL;
        my $grub_bak  = $grub2_info->{'backup_dir'};

        my ( $skipped_copy, $failed_copy ) = ( 0, 0 );

        eval {
            my %grub2_entries;

            opendir my $grub2_dir_fh, $grub2_dir or die "Unable to open directory $grub2_dir: $!";
            while ( my $entry = readdir $grub2_dir_fh ) {
                $grub2_entries{$entry} = 1;
            }
            closedir $grub2_dir_fh;

            opendir my $grub_bak_fh, $grub_bak or die "Unable to open directory $grub_bak: $!";
            while ( my $entry = readdir $grub_bak_fh ) {

                next if $entry eq '.';
                next if $entry eq '..';

                next if $entry eq "grub.cfg";

                if ( exists $grub2_entries{$entry} ) {
                    $skipped_copy++;
                    WARN("\"$grub_bak/$entry\" is not being copied to \"$grub2_dir/$entry\" because the destination already exists.");
                    next;
                }

                if ( !File::Copy::Recursive::rcopy( "$grub_bak/$entry", "$grub2_dir/$entry" ) ) {
                    $failed_copy++;
                    WARN("Copying \"$grub_bak/$entry\" into \"$grub2_dir\" failed.");
                }
            }
            closedir $grub_bak_fh;
        };
        WARN("Unable to copy the contents of \"$grub_bak\" into \"$grub2_dir\": $@") if $@;

        my $log_file = Elevate::Constants::LOG_FILE;

        Elevate::Notify::add_final_notification( <<~EOS ) if ( $skipped_copy > 0 || $failed_copy > 0 );
        After converting "$grub_dir" from a directory to a symlink to
        "$grub2_dir", the upgrade process chose not to copy $skipped_copy
        entries from the old directory due to name conflicts, and it failed to
        copy $failed_copy entries due to system errors. The previous contents
        of "$grub_dir" are now located at "$grub_bak". See $log_file for
        further information.

        If you did not add these files or otherwise customize the boot loader
        configuration, you may ignore this message.
        EOS

        return;
    }

    sub post_leapp ($self) {

        my $proc_cmd_line = eval { File::Slurper::read_binary('/proc/cmdline') } // '';
        return unless $proc_cmd_line =~ m{net.ifnames=0};

        my $grub_conf = eval { File::Slurper::read_binary(Elevate::Constants::DEFAULT_GRUB_FILE) } // '';
        return unless length $grub_conf;
        return if $grub_conf =~ m/net.ifnames/;

        return unless $grub_conf =~ s/GRUB_CMDLINE_LINUX="(.+?)"/GRUB_CMDLINE_LINUX="$1 net.ifnames=0"/m;
        File::Slurper::write_binary( Elevate::Constants::DEFAULT_GRUB_FILE, $grub_conf );

        my $grubenv = Cpanel::SafeRun::Simple::saferunnoerror( GRUB_EDITENV, GRUB_ENV_FILE, 'list' );
        foreach my $line ( split "\n", $grubenv ) {
            my ( $name, $value ) = split "=", $line, 2;
            next unless $name eq "kernelopts";

            if ( $value !~ m/\bnet\.ifnames=/a ) {
                $line .= ( $line && $line !~ m/ $/ ? " " : "" ) . 'net.ifnames=0';
                Cpanel::SafeRun::Object->new_or_die(
                    program => GRUB_EDITENV,
                    args    => [
                        GRUB_ENV_FILE,
                        "set",
                        $line,
                    ],
                );
                last;
            }
        }

        return 1;
    }

    1;

}    # --- END lib/Elevate/Components/Grub2.pm

{    # --- BEGIN lib/Elevate/Components/Imunify.pm

    package Elevate::Components::Imunify;

    use cPstrict;

    use Elevate::Constants ();
    use Elevate::Notify    ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use Cpanel::JSON            ();
    use Cpanel::SafeRun::Simple ();
    use File::Copy              ();

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    use constant IMUNIFY_AGENT          => Elevate::Constants::IMUNIFY_AGENT;                                         # ya alias
    use constant IMUNIFY_LICENSE_FILE   => '/var/imunify360/license.json';
    use constant IMUNIFY_LICENSE_BACKUP => Elevate::Constants::ELEVATE_BACKUP_DIR . '/imunify-backup-license.json';

    sub pre_leapp ($self) {

        $self->run_once("_capture_imunify_features");

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_restore_imunify_features');

        return;
    }

    sub _capture_imunify_features {
        return unless -x IMUNIFY_AGENT;

        my $output   = Cpanel::SafeRun::Simple::saferunnoerror( IMUNIFY_AGENT, qw{features list} );
        my @features = map { s/\s+//g; $_ } grep { m/\S/ } split( "\n", $output );

        if ( -f IMUNIFY_LICENSE_FILE ) {
            File::Copy::move( IMUNIFY_LICENSE_FILE, IMUNIFY_LICENSE_BACKUP );
        }

        cpev::update_stage_file( { 'reinstall' => { 'imunify_features' => \@features } } );

        return;
    }

    sub _restore_imunify_features {

        return unless my $features = cpev::read_stage_file('reinstall')->{'imunify_features'};

        File::Copy::move( IMUNIFY_LICENSE_BACKUP, IMUNIFY_LICENSE_FILE ) if -f IMUNIFY_LICENSE_BACKUP;

        return unless ref $features eq 'ARRAY';
        return unless @$features;

        INFO("Restoring imunify 360 features.");
        foreach my $feature (@$features) {
            INFO("Restoring imunify360 $feature");
            my $log_file = Cpanel::SafeRun::Simple::saferunnoerror( IMUNIFY_AGENT, qw{features install }, $feature );
            $log_file or next;
            chomp $log_file;
            next unless $log_file =~ m/\S/;

            __monitor_imunify_feature_install( $feature, $log_file );
        }

        return;
    }

    sub __imunify_feature_install_status ($feature) {
        my $install_status = eval {
            my $json = Cpanel::SafeRun::Simple::saferunnoerror( IMUNIFY_AGENT, qw{features status}, $feature, '--json' ) // '{}';
            Cpanel::JSON::Load($json);
        } // {};

        my $status = $install_status->{'items'}->{'status'} // '';

        return $status if $status =~ m/^(installed|installing|not_installed)$/i;
        return $install_status->{'items'}->{'message'} || "$feature is unknown";
    }

    sub __monitor_imunify_feature_install ( $feature, $log_file ) {

        my $start = time;
        while ( time - $start < 30 ) {
            my $status = __imunify_feature_install_status($feature);
            last if ( $status eq 'installed' || $status eq 'installing' && -e $log_file );
        }

        open( my $fh, '<', $log_file ) or do {
            my $status = __imunify_feature_install_status($feature);
            WARN("Could not open $log_file for monitoring ($!). The install of $feature is in state: $status");
            return;
        };

        DEBUG("Monitoring $log_file for completion");

        $start = time;
        my $partial_line = '';
        while ( time - $start < 60 * 20 ) {    # abort after 20 minutes.

            while ( my $read = <$fh> ) {
                my $partial_line .= $read;
                if ( length $read && substr( $partial_line, -1, 1 ) eq "\n" ) {
                    INFO($partial_line);
                    $partial_line = '';
                }
            }

            my $status = __imunify_feature_install_status($feature);
            if ( $status eq 'installed' ) {
                INFO("Restore of $feature complete.");
                return 1;
            }
            if ( $status ne 'installing' ) {
                FATAL("Failed to install imunify 360 feature $feature ($status)");
                FATAL("See $log_file for more information");
                return 0;
            }

            sleep 5;
        }

        Elevate::Notify::add_final_notification( "Imunify failed to install feature $feature", 1 );

        return 0;
    }
    1;

}    # --- END lib/Elevate/Components/Imunify.pm

{    # --- BEGIN lib/Elevate/Components/Imunify360.pm

    package Elevate::Components::Imunify360;

    use cPstrict;

    use Elevate::Constants ();
    use Elevate::Fetch     ();

    use Cpanel::JSON ();
    use Cwd          ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        $self->run_once("_remove_imunify_360");

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_reinstall_imunify_360');

        return;
    }

    sub _remove_imunify_360 ($self) {

        my $im360 = Cpanel::Pkgr::is_installed('imunify360-firewall');
        my $imav  = Cpanel::Pkgr::is_installed('imunify-antivirus');
        return unless $im360 || $imav;

        my $agent_bin = Elevate::Constants::IMUNIFY_AGENT;
        return unless -x $agent_bin;
        my $license_data = eval { Cpanel::JSON::Load(`$agent_bin version --json 2>&1`) } // {};
        return unless $license_data->{'license'}->{'status'};    # Must be true.

        my $product_type = $license_data->{'license'}->{'license_type'};

        INFO("Removing $product_type prior to upgrade.");

        cpev::update_stage_file( { 'reinstall' => { 'imunify' => $product_type } } );
        INFO("Product $product_type detected. Uninstalling before upgrade for later restore");

        my $installer_script = _fetch_imunify_installer($product_type) or return;

        $self->ssystem( '/usr/bin/bash', $installer_script, '--uninstall' );
        unlink $installer_script;

        $self->remove_rpms_from_repos('imunify');

        return;
    }

    sub _reinstall_imunify_360 ($self) {
        my $product_type = cpev::read_stage_file('reinstall')->{'imunify'} or return;

        my $installer_script = _fetch_imunify_installer($product_type) or return;

        $self->ssystem( '/usr/bin/bash', $installer_script );
        unlink $installer_script;

        return;
    }

    sub _fetch_imunify_installer ($product) {

        $product =~ s/Plus/+/;
        my %installer_scripts = (
            'imunifyAV'  => 'https://repo.imunify360.cloudlinux.com/defence360/imav-deploy.sh',
            'imunifyAV+' => 'https://repo.imunify360.cloudlinux.com/defence360/imav-deploy.sh',
            'imunify360' => 'https://www.repo.imunify360.cloudlinux.com/defence360/i360deploy.sh',
        );

        my $installer_url = $installer_scripts{$product} or do {
            ERROR("Unknown product type $product");
            return;
        };

        return Elevate::Fetch::script( $installer_url, 'imunify_installer' );
    }

    1;

}    # --- END lib/Elevate/Components/Imunify360.pm

{    # --- BEGIN lib/Elevate/Components/InfluxDB.pm

    package Elevate::Components::InfluxDB;

    use cPstrict;

    use Elevate::Constants ();

    use Cpanel::Pkgr ();
    use Cwd          ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        cpev::remove_from_stage_file('reinstall.influxdb');

        return unless Cpanel::Pkgr::is_installed('telegraf');

        INFO("Not removing influxdb. Will re-install it after elevate.");
        cpev::update_stage_file( { 'reinstall' => { 'influxdb' => 1 } } );

        return;
    }

    sub post_leapp ($self) {

        return unless cpev::read_stage_file('reinstall')->{'influxdb'};

        INFO("Re-installing telegraf for influxdb");
        $self->ssystem_and_die(qw{/usr/bin/yum -y reinstall telegraf});

        return;
    }

    1;

}    # --- END lib/Elevate/Components/InfluxDB.pm

{    # --- BEGIN lib/Elevate/Components/JetBackup.pm

    package Elevate::Components::JetBackup;

    use cPstrict;

    use Cpanel::Pkgr       ();
    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        cpev::remove_from_stage_file('reinstall.jetbackup');

        return unless Cpanel::Pkgr::is_installed('jetbackup5-cpanel');

        my $repos = cpev::yum_list();
        my $jetbackup_tier =
            $repos->{'jetapps-stable'} ? 'jetapps-stable'
          : $repos->{'jetapps-edge'}   ? 'jetapps-edge'
          : $repos->{'jetapps-beta'}   ? 'jetapps-beta'
          :                              'jetapps-stable';    # Just give up and choose stable if you can't guess.
        INFO("Jetbackup tier '$jetbackup_tier' detected. Not removing jetbackup. Will re-install it after elevate.");
        my @reinstall = cpev::get_installed_rpms_in_repo(qw/jetapps jetapps-stable jetapps-beta jetapps-edge/);
        unshift @reinstall, $jetbackup_tier;

        my $data = {
            tier     => $jetbackup_tier,
            packages => \@reinstall,
        };

        cpev::update_stage_file( { 'reinstall' => { 'jetbackup' => $data } } );

        return;
    }

    sub post_leapp ($self) {

        my $data = cpev::read_stage_file('reinstall')->{'jetbackup'};
        return unless ref $data && ref $data->{packages};

        INFO("Re-installing jetbackup.");

        my $tier     = $data->{tier};
        my @packages = $data->{packages}->@*;
        $self->ssystem( qw{/usr/bin/yum -y reinstall  --disablerepo=* --enablerepo=jetapps}, "--enablerepo=$tier", @packages );

        return;
    }

    1;

}    # --- END lib/Elevate/Components/JetBackup.pm

{    # --- BEGIN lib/Elevate/Components/LiteSpeed.pm

    package Elevate::Components::LiteSpeed;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        cpev::remove_from_stage_file('reinstall.litespeed');

        my $ls_cfg_dir = q[/usr/local/lsws/conf];
        return unless -d $ls_cfg_dir;

        INFO("LiteSpeed is installed");

        $self->ssystem(qw{/usr/local/lsws/bin/lshttpd -V});
        my $has_valid_license = $? == 0 ? 1 : 0;

        my $data = {
            has_valid_license => $has_valid_license,
        };

        cpev::update_stage_file( { 'reinstall' => { 'litespeed' => $data } } );

        return;
    }

    sub post_leapp ($self) {

        my $data = cpev::read_stage_file('reinstall')->{'litespeed'};
        return unless ref $data;

        INFO("Checking LiteSpeed");

        if ( $data->{has_valid_license} ) {
            $self->ssystem(qw{/usr/local/lsws/bin/lshttpd -V});
            ERROR("LiteSpeed license is not valid. Check /usr/local/lsws/conf/serial.no") if $? != 0;
        }

        $self->ssystem(qw{/usr/bin/systemctl restart lsws});

        return;
    }

    1;

}    # --- END lib/Elevate/Components/LiteSpeed.pm

{    # --- BEGIN lib/Elevate/Components/KernelCare.pm

    package Elevate::Components::KernelCare;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd        ();
    use File::Copy ();

    # use Log::Log4perl  qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }
    use Elevate::Fetch ();

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        $self->run_once("_remove_kernelcare_if_needed");

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_restore_kernelcare');

        return;
    }

    sub _remove_kernelcare_if_needed ($self) {

        return unless -x q[/usr/bin/kcarectl];

        local $ENV{KCARE_KEEP_REGISTRATION} = '1';
        $self->remove_rpms_from_repos('kernelcare');

        cpev::update_stage_file( { 'reinstall' => { 'kernelcare' => 1 } } );

        return 1;
    }

    sub _restore_kernelcare ($self) {
        return unless cpev::read_stage_file('reinstall')->{'kernelcare'};

        INFO("Restoring kernelcare");

        INFO("Retrieving kernelcare installer");
        my $installer_script = Elevate::Fetch::script( 'https://kernelcare.com/installer', 'kernelcare_installer' );

        my $conf_file = q[/etc/sysconfig/kcare/kcare.conf];
        if ( -e $conf_file . q[.rpmsave] ) {
            INFO("Restoring Configuration file: $conf_file");

            File::Copy::copy( $conf_file . q[.rpmsave], $conf_file );
        }

        INFO("Running kernelcare installer");
        $self->ssystem_and_die( '/usr/bin/bash' => $installer_script );

        unlink $installer_script;

        INFO("Updating kernelcare");
        $self->ssystem(qw{ /usr/bin/kcarectl --update });

        return;
    }

    1;

}    # --- END lib/Elevate/Components/KernelCare.pm

{    # --- BEGIN lib/Elevate/Components/Kernel.pm

    package Elevate::Components::Kernel;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_kernel_check');

        return;
    }

    sub _kernel_check ($self) {

        my @kernel_rpms = `/usr/bin/rpm -qa`;
        @kernel_rpms = sort grep { m/^kernel-\S+el7/ } @kernel_rpms;

        return unless @kernel_rpms;
        chomp @kernel_rpms;

        my $pretty_distro_name = $self->upgrade_to_pretty_name();

        my $msg = "The following kernels should probably be removed as they will not function on $pretty_distro_name:\n\n";
        foreach my $kernel (@kernel_rpms) {
            $msg .= "    $kernel\n";
        }

        $msg .= "\nYou can remove these by running: /usr/bin/rpm -e " . join( " ", @kernel_rpms ) . "\n";

        Elevate::Notify::add_final_notification($msg);

        return;
    }

    1;

}    # --- END lib/Elevate/Components/Kernel.pm

{    # --- BEGIN lib/Elevate/Components/MySQL.pm

    package Elevate::Components::MySQL;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        $self->run_once("_cleanup_mysql_packages");

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_reinstall_mysql_packages');

        return;
    }

    sub _cleanup_mysql_packages ($self) {

        my $mysql_version = cpev::read_stage_file( 'mysql-version', '' );
        return unless length $mysql_version;

        INFO("# Cleanup MySQL packages ; using version $mysql_version");

        cpev::update_stage_file( { 'mysql-version' => $mysql_version } );

        $self->_cleanup_mysql_57_packages();
        $self->_cleanup_mysql_80_packages();
        $self->_cleanup_mysql_102_packages();
        $self->_cleanup_mysql_103_packages();
        $self->_cleanup_mysql_105_packages();
        $self->_cleanup_mysql_106_packages();

        return;
    }

    sub _reinstall_mysql_packages {

        my $mysql_version = cpev::read_stage_file( 'mysql-version', '' ) or return;

        INFO("Restoring MySQL $mysql_version");

        my ( $major, $minor ) = split( /\./, $mysql_version );

        my $out = Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/local/cpanel/bin/whmapi1 start_background_mysql_upgrade}, "version=$mysql_version" );
        die qq[Fail to restore MySQL $mysql_version] if $?;

        if ( $out =~ m{\supgrade_id:\s*(\S+)} ) {
            my $id = $1;

            INFO("Restoring MySQL via upgrade_id $id");
            INFO('Waiting for MySQL installation');

            my $status = '';

            my $c = 0;

            while (1) {
                $c   = ( $c + 1 ) % 10;
                $out = Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/local/cpanel/bin/whmapi1 background_mysql_upgrade_status }, "upgrade_id=$id" );
                die qq[Fail to restore MySQL $mysql_version: cannot check upgrade_id=$id] if $?;

                if ( $out =~ m{\sstate:\s*inprogress} ) {
                    print ".";
                    print "\n" if $c == 0;
                    sleep 5;
                    next;
                }

                if ( $out =~ m{\sstate:\s*(\w+)} ) {
                    $status = $1;
                }
                last;
            }

            print "\n" if $c;    # clear the last "." from above

            if ( $status eq 'success' ) {
                INFO("MySQL $mysql_version restored");
            }
            else {
                FATAL("Failed to restore MySQL $mysql_version: upgrade $id status '$status'");
                FATAL("$out");
                die 'Failed to restore MySQL';
            }
        }
        else {
            die qq[Cannot find upgrade_id from start_background_mysql_upgrade:\n$out];
        }

        return;
    }

    sub _cleanup_mysql_57_packages ($self) {
        my @repos = qw{
          Mysql-connectors-community
          Mysql-tools-community
          Mysql57-community
          Mysql-tools-preview
        };

        $self->remove_rpms_from_repos(@repos);

        return;
    }

    sub _cleanup_mysql_80_packages ($self) {

        my @repos = qw{
          Mysql-connectors-community
          Mysql-tools-community
          Mysql80-community
          Mysql-tools-preview
        };

        $self->remove_rpms_from_repos(@repos);

        return;
    }

    sub _cleanup_mysql_102_packages ($self) {

        $self->remove_rpms_from_repos('MariaDB102');

        return;
    }

    sub _cleanup_mysql_103_packages ($self) {

        $self->remove_rpms_from_repos('MariaDB103');

        return;
    }

    sub _cleanup_mysql_105_packages ($self) {

        $self->remove_rpms_from_repos('MariaDB105');

        return;
    }

    sub _cleanup_mysql_106_packages ($self) {

        $self->remove_rpms_from_repos('MariaDB106');

        return;
    }

    1;

}    # --- END lib/Elevate/Components/MySQL.pm

{    # --- BEGIN lib/Elevate/Components/NixStats.pm

    package Elevate::Components::NixStats;

    use cPstrict;

    use Elevate::Constants        ();
    use Elevate::SystemctlService ();
    use Elevate::Fetch            ();
    use Elevate::Notify           ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        $self->run_once("_remove_nixstats");

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_restore_nixstats');

        return;
    }

    sub has_nixstats {
        return -e q[/etc/systemd/system/nixstatsagent.service] || -e q[/usr/local/bin/nixstatsagent];
    }

    sub _remove_nixstats ($self) {

        return unless has_nixstats();

        INFO("Removing nixstats");

        my $backup_dir = Elevate::Constants::ELEVATE_BACKUP_DIR . "/nixstats";

        File::Path::make_path($backup_dir);
        die "Fail to create backup directory: $backup_dir" unless -d $backup_dir;

        my @to_backup = qw{ /etc/nixstats-token.ini /etc/nixstats.ini };

        my $to_restore = {};

        foreach my $f (@to_backup) {
            next unless -f $f;
            my $name   = File::Basename::basename($f);
            my $backup = "$backup_dir/$name";
            File::Copy::move( $f, $backup );

            $to_restore->{$backup} = $f;
        }

        my $service_name = q[nixstatsagent];
        my $service      = Elevate::SystemctlService->new( name => $service_name );

        my $is_enabled = $service->is_enabled;

        $service->disable if $is_enabled;
        $service->stop;

        my $pip;

        if ( -x q[/usr/bin/pip3] ) {
            $pip = q[/usr/bin/pip3];
        }
        elsif ( -x q[/usr/bin/pip] ) {
            $pip = q[/usr/bin/pip];
        }

        if ($pip) {
            $self->ssystem( $pip, qw{uninstall -y nixstatsagent} );
        }
        else {
            ERROR("Cannot remove nixstatsagent: cannot find pip binary");
        }

        my $data = {
            service_enabled => $is_enabled,
            to_restore      => $to_restore,
        };

        cpev::update_stage_file( { 'reinstall' => { 'nixstats' => $data } } );

        return;
    }

    sub _restore_nixstats ($self) {
        my $data = cpev::read_stage_file('reinstall')->{'nixstats'};
        return unless ref $data;

        INFO("Restoring nixstats");

        my $user = q[deadbeefdeadbeefdeadbeef];

        my $installer_script = Elevate::Fetch::script( 'https://www.nixstats.com/nixstatsagent.sh', 'nixstatsagent' );

        $self->ssystem( '/usr/bin/bash', $installer_script, $user );

        unlink $installer_script;

        if ( !-x q[/usr/local/bin/nixstatsagent] ) {
            ERROR("Missing nixstatsagent binary: /usr/local/bin/nixstatsagent");
        }

        my $service = q[nixstatsagent];

        $self->ssystem( qw{/usr/bin/systemctl stop}, $service );

        my $to_restore = $data->{to_restore};

        foreach my $src ( sort keys %$to_restore ) {
            my $destination = $to_restore->{$src};

            File::Copy::copy( $src, $destination );
        }

        if ( $data->{service_enabled} ) {
            $self->ssystem( qw{/usr/bin/systemctl enable}, $service );
        }
        else {    # leave it disabled
            $self->ssystem( qw{/usr/bin/systemctl disable}, $service );
        }

        $self->ssystem( qw{/usr/bin/systemctl start}, $service );
        if ( $? == 0 ) {
            INFO("nixstatsagent restored");
        }
        else {
            Elevate::Notify::add_final_notification( "Failed to start nixstatsagent.service", 1 );
        }

        return;
    }

    1;

}    # --- END lib/Elevate/Components/NixStats.pm

{    # --- BEGIN lib/Elevate/Components/PECL.pm

    package Elevate::Components::PECL;

    use cPstrict;

    use Elevate::Constants ();

    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        $self->run_once("_backup_pecl_packages");

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_check_pecl_packages');

        return;
    }

    sub _backup_pecl_packages ($self) {
        my @ea_versions = qw{ea-php70 ea-php71 ea-php72 ea-php73 ea-php74 ea-php80};

        foreach my $v (@ea_versions) {
            _store_pecl_for( qq[/opt/cpanel/$v/root/usr/bin/pecl], $v );
        }

        _store_pecl_for( q[/usr/local/cpanel/3rdparty/bin/pecl], 'cpanel' );

        return;
    }

    sub _check_pecl_packages ($self) {

        my $pecl = cpev::read_stage_file('pecl');

        return unless ref $pecl && scalar keys $pecl->%*;

        foreach my $v ( sort keys $pecl->%* ) {
            my $previously_installed = $pecl->{$v};

            return unless ref $previously_installed && scalar keys $previously_installed->%*;

            my $bin;
            if ( $v eq 'cpanel' ) {
                $bin = q[/usr/local/cpanel/3rdparty/bin/pecl];
            }
            else {
                $bin = qq[/opt/cpanel/$v/root/usr/bin/pecl];
            }

            my $currently_installed = _get_pecl_installed_for($bin) // {};

            my $final_notification;

            my $displayed_header = 0;
            foreach my $pkg ( sort keys $previously_installed->%* ) {
                next if $currently_installed->{$pkg};

                if ( !$displayed_header ) {
                    $displayed_header = 1;
                    WARN( q[*] x 20 );

                    $final_notification = <<~"EOS";
                WARNING: Missing pecl package(s) for $bin
                Please reinstall these packages:
                EOS

                    foreach my $l ( split( "\n", $final_notification ) ) {
                        next unless length $l;
                        WARN($l);
                    }

                    WARN( q[*] x 20 );
                }

                WARN("- $pkg");
                $final_notification .= qq[- $pkg\n];
            }

            Elevate::Notify::add_final_notification($final_notification);

            WARN('#') if $displayed_header;
        }

        return;
    }

    sub _store_pecl_for ( $bin, $name ) {
        my $list = _get_pecl_installed_for($bin);

        cpev::remove_from_stage_file("pecl.$name");

        return unless ref $list && scalar keys $list->%*;

        cpev::update_stage_file( { pecl => { $name => $list } } );

        return;
    }

    sub _get_pecl_installed_for ($bin) {

        return unless -x $bin;

        my $out = Cpanel::SafeRun::Simple::saferunnoerror( $bin, 'list' ) // '';
        return if $?;

        my @lines = split( /\n/, $out );
        return unless scalar @lines >= 4;

        shift @lines for 1 .. 3;    # remove the header

        my $installed;

        foreach my $l (@lines) {
            my ( $package, $v, $state ) = split( /\s+/, $l, 3 );
            $installed->{$package} = $v;
        }

        return $installed;
    }

    1;

}    # --- END lib/Elevate/Components/PECL.pm

{    # --- BEGIN lib/Elevate/Components/PerlXS.pm

    package Elevate::Components::PerlXS;

    use cPstrict;

    use Elevate::Constants ();
    use Elevate::Notify    ();

    use Config;
    use Cwd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }
    use File::Find ();

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    use constant DISTRO_PERL_XS_PATH => '/usr/local/lib64/perl5';

    sub pre_leapp ($self) {

        $self->purge_perl_xs(DISTRO_PERL_XS_PATH);
        $self->purge_perl_xs( $Config{'installsitearch'} );

        return;
    }

    sub post_leapp ($self) {

        restore_perl_xs(DISTRO_PERL_XS_PATH);
        restore_perl_xs( $Config{'installsitearch'} );

        return;
    }

    sub purge_perl_xs ( $self, $path ) {

        return unless length $path && -d $path;

        my @perl_modules;

        File::Find::find(
            sub {
                return unless substr( $_, -3 ) eq '.pm';
                return if -l $_;
                return unless -f $_;

                push @perl_modules, $File::Find::name;

            },
            $path
        );

        my $path_len = length($path);
        @perl_modules = map { substr( $_, $path_len + 1 ) } sort { $a cmp $b } @perl_modules;

        my $xspm_to_rpm = xspm_to_rpm();

        my %rpms_to_restore;
        my @modules_to_restore;
        foreach my $file (@perl_modules) {

            if ( $path eq DISTRO_PERL_XS_PATH && length $xspm_to_rpm->{$file} ) {
                $rpms_to_restore{$file} = $xspm_to_rpm->{$file};
            }
            else {
                push @modules_to_restore, $file;
            }
        }

        my $pretty_distro_name = $self->upgrade_to_pretty_name();

        my $stash = {};
        if (%rpms_to_restore) {
            INFO("The following `cpan` installed perl Modules will be removed and replaced with a $pretty_distro_name RPM after upgrade:");
            foreach my $file ( sort { $rpms_to_restore{$a} cmp $rpms_to_restore{$b} || $a cmp $b } keys %rpms_to_restore ) {
                INFO( sprintf( "  %20s => %s", $file, $rpms_to_restore{$file} ) );

                my $files_in_rpm = $stash->{'restore'}->{$path}->{'rpm'}->{ $rpms_to_restore{$file} } //= [];
                unless ( grep { $_ eq $file } @$files_in_rpm ) {    # Only if we've not stored this.
                    push @$files_in_rpm, $file;
                    unlink "$path/$file";
                }
            }
            INFO(' ');
        }

        if (@modules_to_restore) {
            WARN("The following modules will likely not be functional on $pretty_distro_name and will be disabled. You will need to restore these manually:");
            my $to_restore = $stash->{'restore'}->{$path}->{'cpan'} //= [];
            foreach my $file (@modules_to_restore) {
                WARN("    $path/$file");
                next if grep { $_ eq $file } @$to_restore;    # We've already stashed this.
                push @$to_restore, $file;
                rename "$path/$file", "$path/$file.o";
            }
        }

        cpev::update_stage_file($stash);

        return;
    }

    sub restore_perl_xs ($path) {
        my $stash = cpev::read_stage_file();

        if ( $path eq DISTRO_PERL_XS_PATH ) {
            my $rpms = $stash->{'restore'}->{ DISTRO_PERL_XS_PATH() }->{'rpm'};

            if ( scalar keys %$rpms ) {    # If there are no XS modules to replace, there is no point to running the dnf install:
                my @cmd = ( '/usr/bin/dnf', '-y', '--enablerepo=epel', '--enablerepo=powertools', 'install', sort keys %$rpms );
                __PACKAGE__->ssystem(@cmd);
            }
        }

        my $cpan_modules = $stash->{$path}->{'cpan'} // return;

        my $msg = "The following XS modules will need to be re-installed:\n\n";
        foreach my $module (@$cpan_modules) {
            $msg .= "   $module\n";
        }

        Elevate::Notify::add_final_notification($msg);

        return;
    }

    sub xspm_to_rpm () {
        return {
            'IO/Pty.pm'           => 'perl-IO-Tty',
            'IO/Tty.pm'           => 'perl-IO-Tty',
            'IO/Tty/Constant.pm'  => 'perl-IO-Tty',
            'JSON/Syck.pm'        => 'perl-YAML-Syck',
            'JSON/XS.pm'          => 'perl-JSON-XS',
            'JSON/XS/Boolean.pm'  => 'perl-JSON-XS',
            'YAML/Dumper/Syck.pm' => 'perl-YAML-Syck',
            'YAML/Loader/Syck.pm' => 'perl-YAML-Syck',
            'YAML/Syck.pm'        => 'perl-YAML-Syck',
            'common/sense.pm'     => 'perl-common-sense',
            'version.pm'          => 'perl-version',
            'version/regex.pm'    => 'perl-version',
            'version/vpp.pm'      => 'perl-version',
            'version/vxs.pm'      => 'perl-version',
        };
    }

    1;

}    # --- END lib/Elevate/Components/PerlXS.pm

{    # --- BEGIN lib/Elevate/Components/Repositories.pm

    package Elevate::Components::Repositories;

    use cPstrict;

    use Elevate::Constants              ();
    use Elevate::Blockers::Repositories ();

    use Cpanel::SafeRun::Simple ();
    use Cwd                     ();
    use File::Copy              ();

    # use Log::Log4perl           qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        $self->run_once("_disable_known_yum_repositories");

        return;
    }

    sub _disable_known_yum_repositories {

        my @repo_files = map { Elevate::Constants::YUM_REPOS_D . '/' . $_ }    #
          Elevate::Blockers::Repositories::DISABLE_MYSQL_YUM_REPOS;

        foreach my $f (@repo_files) {
            next unless -e $f;
            if ( -l $f ) {
                unlink $f;
                next;
            }

            File::Copy::move( $f, "$f.off" ) or die qq[Fail to disable repo $f];
        }

        Cpanel::SafeRun::Simple::saferunnoerror(qw{/usr/bin/yum clean all});

        return;
    }

    1;

}    # --- END lib/Elevate/Components/Repositories.pm

{    # --- BEGIN lib/Elevate/Components/WPToolkit.pm

    package Elevate::Components::WPToolkit;

    use cPstrict;

    use Elevate::Constants ();
    use Elevate::Fetch     ();

    use Cpanel::SafeRun::Errors ();
    use Cwd                     ();
    use File::Copy              ();

    # use Log::Log4perl           qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    # use Elevate::Components::Base();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Components::Base); }

    sub pre_leapp ($self) {

        $self->run_once("_remove_wordpress_toolkit");

        return;
    }

    sub post_leapp ($self) {

        $self->run_once('_reinstall_wordpress_toolkit');

        return;
    }

    sub _remove_wordpress_toolkit ($self) {
        return unless Cpanel::Pkgr::is_installed('wp-toolkit-cpanel');

        INFO("Removing Wordpress Toolkit");

        INFO("Removing the rpm wp-toolkit-cpanel (--noscripts)");
        backup_3rdparty_file('/usr/local/cpanel/3rdparty/wp-toolkit/var/wp-toolkit.sqlite3');
        backup_3rdparty_file('/usr/local/cpanel/3rdparty/wp-toolkit/var/etc/.shadow');

        my ($output) = Cpanel::SafeRun::Errors::saferunallerrors(qw{/usr/bin/rpm -e --noscripts wp-toolkit-cpanel});
        DEBUG($output) if $output;

        cpev::yum_list(1);    # Invalidate the cache since we just ran an rpm -e by hand.
        $self->remove_rpms_from_repos(qw/wp-toolkit-cpanel wp-toolkit-thirdparties/);

        cpev::update_stage_file( { 'reinstall' => { 'wordpress_toolkit' => 1 } } );

        return;
    }

    sub _reinstall_wordpress_toolkit ($self) {
        return unless cpev::read_stage_file('reinstall')->{'wordpress_toolkit'};

        INFO("Restoring Wordpress Toolkit");
        my $installer_script = Elevate::Fetch::script( 'https://wp-toolkit.plesk.com/cPanel/installer.sh', 'wptk_installer' );

        $self->ssystem( '/usr/bin/bash', $installer_script );
        unlink $installer_script;

        return;
    }

    sub backup_3rdparty_file ($file) {
        my $target = "$file.elevate_backup";
        return File::Copy::copy( $file, $target );
    }

    1;

}    # --- END lib/Elevate/Components/WPToolkit.pm

{    # --- BEGIN lib/Elevate/Fetch.pm

    package Elevate::Fetch;

    use cPstrict;

    use Elevate::Constants   ();
    use Cpanel::HTTP::Client ();
    use File::Temp           ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub script ( $url, $template, $suffix = '.sh' ) {
        my $response = eval {
            my $http = Cpanel::HTTP::Client->new()->die_on_http_error();
            $http->get($url);
        };

        if ( my $exception = $@ ) {
            ERROR("The system could not fetch the script for $template: $exception");
            return;
        }

        my $fh = File::Temp->new(
            TEMPLATE => "${template}_XXXX",
            SUFFIX   => $suffix,
            UNLINK   => 0,
            PERMS    => 0600,
            TMPDIR   => 1
          )
          or do {
            ERROR(qq[Cannot create a temporary file]);
            return;
          };
        print {$fh} $response->{'content'};
        close $fh;

        return "$fh";
    }

    1;

}    # --- END lib/Elevate/Fetch.pm

{    # --- BEGIN lib/Elevate/Logger.pm

    package Elevate::Logger;

    use cPstrict;

    use Elevate::Constants ();

    use Term::ANSIColor ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    my %colors = (
        TRACE => 'cyan',
        DEBUG => 'bold white',
        INFO  => 'green',
        WARN  => 'yellow',
        ERROR => 'red',
        FATAL => 'bold red',
    );

    sub init ( $self, $debug_level = 'DEBUG' ) {
        my $log_file = Elevate::Constants::LOG_FILE;

        my $config = <<~"EOF";
        log4perl.appender.File=Log::Log4perl::Appender::File
        log4perl.appender.File.filename=$log_file
        log4perl.appender.File.syswrite=1
        log4perl.appender.File.layout=Log::Log4perl::Layout::PatternLayout
        log4perl.appender.File.layout.ConversionPattern=* %d{yyyy-MM-dd HH:mm:ss} (%L) [%s%p%u] %m%n
    EOF

        if ( $self->getopt('service') ) {
            $config .= <<~"EOF";
        log4perl.rootLogger = $debug_level, File
        EOF
        }
        else {
            $config .= <<~"EOF";
        log4perl.appender.Screen=Log::Log4perl::Appender::Screen
        log4perl.appender.Screen.stderr=0
        log4perl.appender.Screen.layout=Log::Log4perl::Layout::PatternLayout
        log4perl.appender.Screen.layout.ConversionPattern=* %d{yyyy-MM-dd HH:mm:ss} [%s%p%u] %m{indent=2,chomp}%n
        log4perl.rootLogger = $debug_level, Screen, File
        EOF
        }

        Log::Log4perl::Layout::PatternLayout::add_global_cspec( 's' => sub { Term::ANSIColor::color( $colors{ $_[3] } ) } );
        Log::Log4perl::Layout::PatternLayout::add_global_cspec( 'u' => sub { Term::ANSIColor::color('reset') } );

        Log::Log4perl->init( \$config );

        return;
    }

    sub INFO_nolog ($msg) {

        return _nolog( $msg, 'INFO' );
    }

    sub ERROR_nolog ($msg) {

        return _nolog( $msg, 'ERROR' );
    }

    sub WARN_nolog ($msg) {

        return _nolog( $msg, 'WARN' );
    }

    sub _nolog ( $msg, $type = 'DEBUG' ) {

        return unless length $msg;

        print '# -------------------------> [';
        print Term::ANSIColor::color( $colors{$type} );
        print $type;
        print Term::ANSIColor::color('reset');
        print '] ';
        print Term::ANSIColor::color('bold white');
        say $msg;
        print Term::ANSIColor::color('reset');

        return;
    }

    1;

}    # --- END lib/Elevate/Logger.pm

{    # --- BEGIN lib/Elevate/Motd.pm

    package Elevate::Motd;

    use cPstrict;

    sub setup {

        my $f = _motd_file();

        my $notice = _motd_notice_message();

        local $/;
        my $fh;
        my $content = '';

        if ( open( $fh, '+<', $f ) ) {
            $content = <$fh> // '';
        }
        elsif ( open( $fh, '>', $f ) ) {
            1;
        }

        return 0 if $content =~ qr{elevate in progress}mi;

        print {$fh} "\n" if length($content) && $content !~ qr{\n\z};

        print {$fh} $notice;

        return 1;
    }

    sub cleanup {

        my $f = _motd_file();

        my $content;
        open( my $fh, '+<', $f ) or return;
        {
            local $/;
            $content = <$fh>;
        }

        return 0 unless $content && $content =~ qr{elevate in progress}mi;

        my $notice = _motd_notice_message();

        if ( $content =~ s{\Q$notice\E}{} ) {
            seek( $fh, 0, 0 );
            print {$fh} $content;
            truncate( $fh, tell($fh) );
            close($fh);

            return 1;
        }

        return;
    }

    sub _motd_notice_message {
        return <<~'EOS';
    EOS
    }

    sub _motd_file {    # allow us to mock it, we cannot use Test::MockFile GH #77 - https://github.com/cpanel/Test-MockFile/issues/77
        return q[/etc/motd];
    }

    1;

}    # --- END lib/Elevate/Motd.pm

{    # --- BEGIN lib/Elevate/Notify.pm

    package Elevate::Notify;

    use cPstrict;

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub warn_skip_version_check {
        WARN("The --skip-cpanel-version-check option was specified! This option is provided for testing purposes only! cPanel may not be able to support the resulting conversion. Please consider whether this is what you want.");
        return;
    }

    sub add_final_notification ( $msg, $warn_now = 0 ) {
        my $stage_info = cpev::read_stage_file();

        return unless defined $msg && length $msg;

        cpev::update_stage_file( { final_notifications => [$msg] } );    # stacked to the previously stored

        if ($warn_now) {
            foreach my $l ( split( "\n", $msg ) ) {
                next unless length $l;
                WARN($l);
            }
        }

        return 1;
    }

    sub send_notification ( $subject, $msg, %opts ) {

        eval {
            _send_notification( $subject, $msg, %opts );
            1;
        }
          or warn "Fail to send notification: $@";

        return;
    }

    sub _send_notification ( $subject, $msg, %opts ) {

        my $is_success = delete $opts{is_success};

        require Cpanel::iContact;

        INFO("Sending notification: $subject");

        my $log   = $is_success ? \&INFO : \&ERROR;
        my @lines = split( "\n", $msg );
        foreach my $line (@lines) {
            $log->($line);
        }

        Cpanel::iContact::icontact(
            'application' => 'elevate',
            'subject'     => $subject,
            'message'     => $msg,
        );

        return;
    }
    1;

}    # --- END lib/Elevate/Notify.pm

{    # --- BEGIN lib/Elevate/Roles/Run.pm

    package Elevate::Roles::Run;

    use cPstrict;

    use Cpanel::IOCallbackWriteLine ();
    use Cpanel::SafeRun::Object     ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    sub ssystem_capture_output ( $, @args ) {

        my %opts;
        if ( ref $args[0] ) {
            my $ropts = shift @args;
            %opts = %$ropts;
        }
        $opts{should_capture_output} = 1;

        return _ssystem( \@args, %opts );
    }

    sub ssystem ( $, @args ) {

        my %opts;
        if ( ref $args[0] ) {
            my $ropts = shift @args;
            %opts = %$ropts;
        }

        return _ssystem( \@args, %opts );
    }

    sub ssystem_and_die ( $self, @args ) {
        $self->ssystem(@args) or return 0;
        die "command failed. Fix it and run command.";
    }

    sub _ssystem ( $command, %opts ) {
        my @args = @{ $command // [] };
        INFO( "Running: " . join( " ", @args ) );
        INFO();    # Buffer so they can more easily read the output.

        if ( scalar @args == 1 && $args[0] =~ m/[\$&*(){}\[\]'";\\|?<>~`\n]/ ) {
            unshift @args, qw(/usr/bin/bash -c);
        }

        my $capture_output = { stdout => [], stderr => [] };
        my $program        = shift @args;
        my ( $callback_out, $callback_err ) = map {
            my $label = $_;
            Cpanel::IOCallbackWriteLine->new(
                sub ($line) {
                    chomp $line;
                    INFO($line);
                    if ( $opts{should_capture_output} ) {
                        push $capture_output->{$label}->@*, $line;
                    }
                    return;
                }
            )
        } qw(stdout stderr);
        my $sr = Cpanel::SafeRun::Object->new(
            program      => $program,
            args         => [@args],
            stdout       => $callback_out,
            stderr       => $callback_err,
            timeout      => 0,
            keep_env     => $opts{keep_env} // 0,
            read_timeout => 0,
        );
        INFO();    # Buffer so they can more easily read the output.

        $? = $sr->CHILD_ERROR;    ## no critic qw(Variables::RequireLocalizedPunctuationVars) -- emulate return behavior of system()

        if ( $opts{should_capture_output} ) {
            $capture_output->{status} = $?;
            return $capture_output;
        }

        return $?;
    }

    1;

}    # --- END lib/Elevate/Roles/Run.pm

{    # --- BEGIN lib/Elevate/Script.pm

    package Elevate::Script;

    use cPstrict;

    use Elevate::Constants ();
    use Elevate::Fetch     ();

    use Cpanel::HTTP::Client ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use Simple::Accessor qw{
      latest_version
      base_url
    };

    use constant DEFAULT_ELEVATE_BASE_URL => 'https://raw.githubusercontent.com/cpanel/elevate/release/';

    sub _build_base_url ($self) {
        return $ENV{'ELEVATE_BASE_URL'} || DEFAULT_ELEVATE_BASE_URL;
    }

    sub _build_latest_version ($self) {
        my $response = Cpanel::HTTP::Client->new->get( $self->base_url() . 'version' );
        return undef if !$response->success;
        my $version = $response->content // '';
        chomp $version if length $version;
        return $version;
    }

    sub is_out_of_date ($self) {
        my ( $should_block, $blocker_text ) = ( 0, undef );

        my ( $latest_version, $self_version ) = ( $self->latest_version(), cpev::VERSION() );

        if ( !defined $latest_version ) {
            $should_block = 1;
            $blocker_text = "The script could not fetch information about the latest version.";
        }
        else {
            $should_block = $latest_version == $self_version ? 0 : 1;
            $blocker_text = <<~EOS if $should_block;
            This script (version $self_version) does not appear to be the newest available release ($latest_version).
            Run this script with the --update option:

            /scripts/elevate-cpanel --update
            EOS
        }

        return ( $should_block, $blocker_text );
    }

    sub fetch ($self) {
        return Elevate::Fetch::script( $self->base_url . 'elevate-cpanel', 'elevate-cpanel', '' );
    }

    1;

}    # --- END lib/Elevate/Script.pm

{    # --- BEGIN lib/Elevate/Service.pm

    package Elevate::Service;

    use cPstrict;

    use Cpanel::SafeRun::Simple     ();
    use Cpanel::RestartSrv::Systemd ();

    use Elevate::Constants ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use Elevate::Roles::Run ();    # for fatpck

    use                            # hide
      Simple::Accessor qw{
      name
      file
      short_name
      cpev
      };

    # use Elevate::Roles::Run();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Roles::Run); }

    # use Elevate::SystemctlService();
    BEGIN { push @ISA, qw(Elevate::SystemctlService); }

    sub _build_name {
        return Elevate::Constants::SERVICE_NAME;
    }

    sub _build_file ($self) {
        return Elevate::Constants::SERVICE_DIR . '/' . $self->name;
    }

    sub _build_short_name ($self) {
        my $s = $self->name;
        $s =~ s{\Q.service\E$}{};

        return $s;
    }

    sub _build_cpev {
        die q[Missing cpev];
    }

    sub install ($self) {

        my $pretty_distro_name = $self->cpev->upgrade_to_pretty_name();

        my $name = $self->name;

        INFO( "Installing service $name which will upgrade the server to " . $pretty_distro_name );
        open( my $fh, '>', $self->file ) or die;

        my $log_file = Elevate::Constants::LOG_FILE;

        print {$fh} <<~"EOF";
        [Unit]
        Description=Upgrade process from CentOS 7 to $pretty_distro_name.
        After=network.target network-online.target

        [Service]
        Type=simple
        RemainAfterExit=yes
        ExecStart=/usr/local/cpanel/scripts/elevate-cpanel --service

        [Install]
        WantedBy=multi-user.target
        EOF

        close $fh;

        $self->ssystem_and_die( '/usr/bin/systemctl', 'daemon-reload' );
        $self->ssystem_and_die( '/usr/bin/systemctl', 'enable', $name );

        $self->cpev->bump_stage();

        my $pid = fork();
        die qq[Failed to fork: $!] unless defined $pid;
        if ($pid) {
            INFO("Starting service $name");
            return 0;
        }
        else {
            unlink(Elevate::Constants::PID_FILE);    # release the pid so the service can use it
            $self->ssystem_and_die( '/usr/bin/systemctl', 'start', $name );
            exit(0);
        }
    }

    sub disable ($self) {

        $self->SUPER::disable( 'now' => 0 );
        unlink $self->file;

        return;
    }

    1;

}    # --- END lib/Elevate/Service.pm

{    # --- BEGIN lib/Elevate/SystemctlService.pm

    package Elevate::SystemctlService;

    use cPstrict;

    use Cpanel::SafeRun::Simple     ();
    use Cpanel::RestartSrv::Systemd ();

    # use Log::Log4perl qw(:easy);
    INIT { Log::Log4perl->import(qw{:easy}); }

    use Elevate::Roles::Run ();    # for fatpck

    use                            # hide
      Simple::Accessor qw{
      name
      };

    # use Elevate::Roles::Run();
    our @ISA;
    BEGIN { push @ISA, qw(Elevate::Roles::Run); }

    sub _build_name {
        die q[Missing sevice name ] . __PACKAGE__;
    }

    sub is_active ($self) {

        my $service = $self->name;

        my $is_active;
        Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/bin/systemctl is-active}, $service );
        $is_active = 1 if $? == 0;

        my $info = Cpanel::RestartSrv::Systemd::get_service_info_via_systemd($service);
        $info->{'ActiveState'} //= '';
        $info->{'SubState'}    //= '';

        $is_active = 1 if $info->{'ActiveState'} eq 'activating' && $info->{'SubState'} eq 'start';

        if ( $is_active && $info->{'SubState'} ne 'exited' ) {
            return 1;
        }

        return 0;
    }

    sub is_enabled ($self) {

        my $service = $self->name;

        my $out = Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/bin/systemctl is-enabled}, $service ) // '';
        chomp $out;

        return 1 if $out eq 'enabled';

        return 0;
    }

    sub restart ($self) {
        return $self->ssystem( qw{/usr/bin/systemctl restart}, $self->name );
    }

    sub remove ($self) {

        my $info = eval { Cpanel::RestartSrv::Systemd::get_service_info_via_systemd( $self->name ) } // {};

        $self->stop;
        $self->disable;

        if ( my $path = $info->{FragmentPath} ) {
            unlink $path;
        }

        return;
    }

    sub stop ($self) {

        $self->ssystem( '/usr/bin/systemctl', 'stop', $self->name );

        return;
    }

    sub disable ( $self, %opts ) {

        my $now = $opts{'now'} // 1;    # by default disable it now...

        my @args = qw{ disable };
        push @args, '--now' if $now;

        $self->ssystem( '/usr/bin/systemctl', @args, $self->name );

        return;
    }

    1;

}    # --- END lib/Elevate/SystemctlService.pm

{    # --- BEGIN lib/Elevate/Usage.pm

    package Elevate::Usage;

    use cPstrict;

    use Getopt::Long ();

    sub _OPTIONS {
        return qw(
          help
          service start clean continue manual-reboots status log check:s
          skip-cpanel-version-check skip-elevate-version-check
          update version
          upgrade-to=s
        );
    }

    sub init ( $self, @args ) {

        $self->{_getopt} = {};

        Getopt::Long::GetOptionsFromArray(
            \@args,
            $self->{_getopt},
            _OPTIONS()
        ) or return $self->help( "Invalid Option", 1 );

        return $self->full_help() if $self->getopt('help');
    }

    sub getopt ( $self, $k ) {
        return $self->{_getopt}->{$k};
    }

    sub help ( $self, $msg = undef, $exit_status = undef ) {
        say $self->_help($msg);
        exit( $exit_status // 0 );
    }

    sub full_help ( $self, $msg = undef, $exit_status = undef ) {

        my $out = $self->_help( $msg, 2 );
        my ( $short_help, $extra ) = split( qr{^.+STAGES}m, $out );
        chomp $short_help for 1 .. 2;
        say $short_help;

        exit( $exit_status // 0 );
    }

    sub _help ( $class, $msg = undef, $verbosity = undef ) {

        my $val;
        open my $wfh, '>', \$val or die "Failed to open to a scalar: $!";

        $msg .= "\n" if length $msg;

        local $Pod::Usage::Formatter;
        $Pod::Usage::Formatter = 'Pod::Text::Termcap' if _stdout_is_terminal();

        require 'Pod/Usage.pm';    ##no critic qw(RequireBarewordIncludes)

        my $pod_path = $0;

        'Pod::Usage'->can('pod2usage')->(
            -exitval   => 'NOEXIT',
            -message   => $msg,
            -verbose   => $verbosity,
            -noperldoc => 1,
            -output    => $wfh,
            -input     => $pod_path,
        );

        warn "No POD for $class in $pod_path!" if !$val;

        return $val;
    }

    sub _stdout_is_terminal() { return -t \*STDOUT }

    1;

}    # --- END lib/Elevate/Usage.pm

package main;

# Copyright 2023 cPanel L.L.C.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.

package cpev;

=encoding utf8

=head1 NAME

/scripts/elevate-cpanel

=head1 DESCRIPTION

Helps to upgrade CentOS 7 cPanel servers to AlmaLinux 8 or Rocky Linux 8.

=head1 SYNOPSIS

    /scripts/elevate-cpanel [OPTIONS]

    Optional:
       --start                        Start the convertion process
       --continue                     Continue the convertion: retry the last step
       --check[=BLOCKER_FILE]         Check if your system has any known blockers to upgrade.
       --log                          Show the current elevation log
       --status                       Check the current elevation status
       --clean                        Cleanup scripts and files created by elevate-cpanel
       --upgrade-to=[rocky|almalinux] Update to AlmaLinux 8 or Rocky Linuyx 8
                                      [default to 'almalinux']

       --update                       Instruct the script to replace itself on disk with a downloaded copy of the latest version.
       --version                      Print the version number and exit.

       --skip-elevate-version-check   Skip the check for whether this script is up to date.
       --skip-cpanel-version-check    Skip the check for whether cPanel is up to date.
                                      This option is intended only for testing!

       --help                         Display this documentation.

=head1 COMMON USAGE

=over

=item Start an installation

You can start an elevation update by running:

    # AlmaLinux 8 update
    /scripts/elevate-cpanel --start
    /scripts/elevate-cpanel --start --upgrade-to=almalinux

    # Rocky Linux 8 update
    /scripts/elevate-cpanel --start --upgrade-to=rocky

=item Compatibility check with elevation

You can check if your server is compatible with the upgrade process without
starting an upgrade process.

    # Check AlmaLinux 8 update
    /scripts/elevate-cpanel --check
    /scripts/elevate-cpanel --check --upgrade-to=almalinux

    # Check Rocky Linux 8 update
    /scripts/elevate-cpanel --check --upgrade-to=rocky

This will also save a JSON representation of the blockers to a file, C</var/cpanel/elevate-blockers> by default,
but passing an optional argument will use the file given instead:

    /scripts/elevate-cpanel --check /root/blockers.json

=item Start an installation with manual reboot

You can control the reboots by using the --manual-reboots flag when starting the process.
This can be used for debugging purpose.

    /scripts/elevate-cpanel --start --manual-reboots

=item Monitor an existing installation

Once you have started an elevation process, you can check the current update by running:

    /scripts/elevate-cpanel

You can also check the current status by running

    /scripts/elevate-cpanel --status

You can check and monitor the elevation log

    /scripts/elevate-cpanel --log

=item Resume an installation after an error

If an error occurs during the elevation process, once you have fixed it, you can resume
the update process by running:

    /scripts/elevate-cpanel --continue

=back

=head1 WARNINGS

The elevation process from CentOS 7 to AlmaLinux 8 or Rocky Linux 8 distribution
is not a risk free update.
Depending on the state of your current distribution multiple errors can occur.
We recommend updating your system to the last upstream state before starting.

The elevation process can take several long minutes and requires multiple reboots.
Some reboots are expected to be longer than normal.

Please do not interrupt the reboots and elevation process.

=cut

use cPstrict;

use Elevate::Constants ();

BEGIN {
    # sanity check before loading the script
    eval { require Cpanel::Version::Tiny } or do {
        warn(qq[This script is designed to only run on cPanel servers.\n]);
        exit 1;
    };

    $Cpanel::Version::Tiny::major_version >= Elevate::Constants::MINIMUM_LTS_SUPPORTED
      or do {
        warn qq[You need to upgrade your cPanel server to version ] . Elevate::Constants::MINIMUM_LTS_SUPPORTED    #
          . qq[or later before running this script.\n];
        exit 1;
      };
}

use Log::Log4perl qw(:easy);

use Config;
use Carp                  ();
use Errno                 ();
use File::Basename        ();
use File::Copy            ();
use File::Copy::Recursive ();
use File::Find            ();
use File::Path            ();
use File::Slurper         ();
use File::Spec            ();
use File::Temp            ();
use Hash::Merge           ();
use Term::ANSIColor       ();

use Cpanel::AccessIds::SetUids  ();
use Cpanel::Binaries            ();
use Cpanel::Config::Httpd       ();
use Cpanel::Config::LoadCpConf  ();
use Cpanel::JSON                ();
use Cpanel::OS                  ();
use Cpanel::PID                 ();
use Cpanel::Pkgr                ();
use Cpanel::RestartSrv::Systemd ();
use Cpanel::SafeRun::Simple     ();
use Cpanel::SafeRun::Errors     ();
use Cpanel::SafeRun::Object     ();
use Cpanel::Update::Tiers       ();
use Cpanel::Version::Tiny       ();
use Cpanel::Version::Compare    ();
use Cpanel::Yum::Vars           ();

# FatPack these packages
# - fatpack blockers
use Elevate::Blockers::Base          ();
use Elevate::Blockers                ();
use Elevate::Blockers::Databases     ();
use Elevate::Blockers::DiskSpace     ();
use Elevate::Blockers::Distros       ();
use Elevate::Blockers::DNS           ();
use Elevate::Blockers::EA4           ();
use Elevate::Blockers::ElevateScript ();
use Elevate::Blockers::Grub2         ();
use Elevate::Blockers::IsContainer   ();
use Elevate::Blockers::JetBackup     ();
use Elevate::Blockers::NICs          ();
use Elevate::Blockers::OVH           ();    # using a constant
use Elevate::Blockers::Repositories  ();    # using a constant
use Elevate::Blockers::SSH           ();
use Elevate::Blockers::WHM           ();

# - fatpack Components
use Elevate::Components::ArchRPMs     ();
use Elevate::Components::Base         ();
use Elevate::Components::DigitalOcean ();
use Elevate::Components::EA4          ();
use Elevate::Components::Grub2        ();
use Elevate::Components::Imunify      ();
use Elevate::Components::Imunify360   ();
use Elevate::Components::InfluxDB     ();
use Elevate::Components::JetBackup    ();
use Elevate::Components::LiteSpeed    ();
use Elevate::Components::KernelCare   ();
use Elevate::Components::Kernel       ();
use Elevate::Components::MySQL        ();
use Elevate::Components::NixStats     ();
use Elevate::Components::PECL         ();
use Elevate::Components::PerlXS       ();
use Elevate::Components::Repositories ();
use Elevate::Components::WPToolkit    ();

use Elevate::Fetch            ();
use Elevate::Logger           ();
use Elevate::Motd             ();
use Elevate::Notify           ();
use Elevate::Roles::Run       ();    # used as parent, but ensure fatpack
use Elevate::Script           ();
use Elevate::Service          ();
use Elevate::SystemctlService ();
use Elevate::Usage            ();

#<<V *** DO NOT EDIT THESE LINES MANUALLY ***
use constant VERSION => 7;
#>>V *** DO NOT EDIT THESE LINES MANUALLY ***

use constant CHKSRVD_SUSPEND_FILE => q[/var/run/chkservd.suspend];
use constant ELEVATE_STAGE_FILE   => '/var/cpanel/elevate';
use constant ELEVATE_SUCCESS_FILE => '/var/cpanel/version/elevate';

use constant VALID_STAGES => 5;

use constant IGNORE_OUTDATED_SERVICES_FILE => q[/etc/cpanel/local/ignore_outdated_services];

use constant LEAPP_REPORT_JSON => q[/var/log/leapp/leapp-report.json];
use constant LEAPP_REPORT_TXT  => q[/var/log/leapp/leapp-report.txt];

use constant NOC_RECOMMENDATIONS_TOUCH_FILE => q[/var/cpanel/elevate-noc-recommendations];

# XXX TODO verify that imunify reponames are in fact correct.
# As of now they are straight up guesses.

use constant REBOOT_NEEDED => 4242;    # just one unique id

# prefer string over integers so we can read the configuration file (no need for bitmask)
use constant UPGRADE_TO_ALMALINUX => q[AlmaLinux];
use constant UPGRADE_TO_ROCKY     => q[Rocky];

use Simple::Accessor qw{
  service
  script
  blockers

  _abort_on_first_blocker
};

# after Simple::Accessor
use parent qw{
  Elevate::Roles::Run
  Elevate::Usage
};

exit( __PACKAGE__->run(@ARGV) // 0 ) unless caller;

sub _build_service ($self) {

    # FIXME weaken
    return Elevate::Service->new( cpev => $self );
}

sub _build_blockers ($self) {

    # FIXME weaken
    return Elevate::Blockers->new( cpev => $self );
}

sub _build_script ($self) {
    return Elevate::Script->new;
}

sub _init ( $self_or_pkg, @args ) {

    my $self = ref $self_or_pkg ? $self_or_pkg : $self_or_pkg->new;

    Elevate::Usage::init( $self, @args );
    Elevate::Logger::init($self);

    return $self;
}

sub run ( $pkg, @args ) {

    local $| = 1;

    my $self = _init( $pkg, @args );

    if ( $self->getopt('version') ) {
        say VERSION;
        return 0;
    }

    if ( $self->getopt('update') ) {
        return $self->do_update();
    }

    $self->_parse_opt_upgrade_to();

    if ( $self->getopt('start') ) {
        die qq[Unsupported option with --start\n] if $self->getopt('continue') || $self->getopt('service');
        return 1                                  if $self->start();
    }
    elsif ( $self->getopt('status') ) {
        return $self->check_status();
    }

    return $self->do_cleanup()      if $self->getopt('clean');
    return $self->blockers->check() if defined $self->getopt('check');

    my $stage = get_stage();

    if ( $stage == 0 ) {
        print_box("Please re-run this script with --start if you would like to begin the upgrade process");
        return $self->full_help(1);    # exit
    }

    if ( $self->getopt('start') || $self->getopt('log') ) {
        1;                             # these options are exclusive
    }
    elsif ( $self->getopt('continue') ) {
        $self->continue_elevation();
    }
    elsif ( $self->getopt('service') ) {

        # running from the systemct service
        return $self->run_service_and_notify();
    }

    monitor_upgrade();

    return 0;
}

sub component ( $self, $name ) {    # FIXME -> get_compoment
    my $pkg = qq[Elevate::Components::$name];

    # my $sub = $pkg->can( 'new' ) or die qq[Missing new from $pkg];
    # my $x = $sub->( $pkg, cpev => $self );
    # return $x;
    return $pkg->new( cpev => $self );
}

sub get_blocker ( $self, $name ) {    # helper for tests
    $self->blockers->_get_blocker_for($name);
}

sub _parse_opt_upgrade_to ($self) {

    return unless my $flavor = $self->getopt('upgrade-to');

    if ( !defined $self->getopt('start') && !defined $self->getopt('check') ) {
        die qq[--upgrade-to option is only supported with --start or --check\n];
    }
    $flavor = lc $flavor;
    if ( $flavor !~ m{^(?:almalinux|alma|rocky)$} ) {
        die qq[Invalid --upgrade_to value '$flavor'. Only 'almalinux' or 'rocky' are supported.\n];
    }

    $self->{upgrade_to} = $flavor eq 'rocky' ? UPGRADE_TO_ROCKY : UPGRADE_TO_ALMALINUX;

    return;
}

sub do_update ($self) {

    INFO( "Self-update of script version " . VERSION . " requested." );

    my ( $needs_update, undef ) = $self->script->is_out_of_date();

    if ($needs_update) {
        INFO("Newer version of script found. Downloading.");
        my $temp_file = $self->script->fetch;
        return 1 unless $temp_file;    # Elevate::Fetch::script handled the error msg

        my $running_from = Cwd::abs_path($0) // '';
        if ( File::Copy::move( $temp_file, $running_from ) ) {
            chmod 0700, $running_from;
            my $confirmed_version = Cpanel::SafeRun::Simple::saferunnoerror( $running_from, '--version' );
            chomp $confirmed_version;
            INFO("Script update to version $confirmed_version successful.");
        }
        else {
            ERROR("The system could not replace the existing copy of the script: $!");
            return 1;
        }
    }
    else {
        INFO("Script is up to date.");
    }

    return 0;
}

sub upgrade_to ($self) {    # main helper to know the upgrade_to distro
    return $self->{upgrade_to} if $self->{upgrade_to};
    return read_stage_file( 'upgrade_to', UPGRADE_TO_ALMALINUX );    # default to AlmaLinux
}

sub upgrade_to_rocky ($self) {
    return $self->upgrade_to() eq UPGRADE_TO_ROCKY;
}

sub upgrade_to_pretty_name ($self) {    # used by output messages
    return q[Rocky Linux 8] if $self->upgrade_to_rocky;
    return q[AlmaLinux 8];
}

sub monitor_upgrade {
    my $stage = get_stage();

    my $tail_msg = q[Running: tail -f ] . Elevate::Constants::LOG_FILE;

    my $status = read_stage_file( 'status', 'unknown' );

    if ( $status eq 'success' ) {
        Elevate::Logger::INFO_nolog("# Upgrade was successful. Showing the last lines of the update log.");
    }
    elsif ( $status eq 'running' ) {
        Elevate::Logger::INFO_nolog("# Monitoring existing upgrade (stage=$stage) ; $tail_msg");
    }
    elsif ( $status eq 'failed' ) {
        Elevate::Logger::ERROR_nolog("# Upgrade process failed at stage=$stage ; $tail_msg");
    }
    else {
        Elevate::Logger::WARN_nolog("# Monitoring upgrade file (stage=$stage) ; $tail_msg");
    }

    exec( qw{/usr/bin/tail -n40 -F }, Elevate::Constants::LOG_FILE );
}

sub start ($self) {
    Elevate::Blockers::Distros::bail_out_on_inappropriate_distro();
    my $stage = get_stage();
    if ( $stage != 0 ) {
        my $header;
        if ( $stage > VALID_STAGES ) {
            $header = q[The 'elevate-cpanel' script has already been executed on this server.];
        }
        else {
            $header = qq[An elevation process is currently in progress: running stage $stage];
        }

        die <<~"EOS";
        $header
        You can check the log by running:
            /scripts/elevate-cpanel --log
        or check the elevation status:
            /scripts/elevate-cpanel --check
        EOS

    }

    $self->give_last_chance();

    system touch => Elevate::Constants::LOG_FILE;

    $self->bump_stage();    # init stage number to 1

    # store the manual reboots flag
    if ( $self->getopt('manual-reboots') ) {
        WARN('Manual Reboot would be required between each stages');
        update_stage_file( { manual_reboots => 1 } );
    }

    # prefer over running step1: so status and notifications are enabled
    return $self->run_service_and_notify();
}

# This code used to be in stage 1, but it makes more sense for it to take place before a stage has been set.
sub give_last_chance ($self) {

    my $pretty_distro_name = $self->upgrade_to_pretty_name();

    print_box(qq[/!\ Warning: You are about to convert your cPanel & WHM CentOS 7 to $pretty_distro_name server.]);

    present_noc_recommendations();

    say <<'EOS';

The elevation process can take several long minutes and requires multiple reboots.
Some reboots can be longer than normal, please do not interrupt the process.

Please *do not interrupt* the reboots and elevation process.

You can check at any time the current status of the update by running:

    /scripts/elevate-cpanel

On failures after fixing them you can continue the elevation process by running:

    /scripts/elevate-cpanel --continue

EOS

    Elevate::Notify::warn_skip_version_check() if $self->getopt('skip-cpanel-version-check');    # give one last reminder

    say <<EOS;
This is your chance now to cancel the update process.
You can hit CTRL-C to abort, otherwise the install starts in a few seconds.
EOS

    do { sleep 1; print '.' }
      for 1 .. 6;
    print "\n";

    return;
}

sub continue_elevation ($self) {

    my $status = read_stage_file( 'status', 'unknown' );
    if ( $status eq 'success' ) {
        Elevate::Logger::INFO_nolog("Elevate process was successful. No process to continue.");
        return;
    }

    if ( $self->service->is_active ) {
        Elevate::Logger::WARN_nolog( "The service " . $self->service->name . " is still running. Please wait for it to finish before restarting it." );
        return;
    }

    # check that no process is running and remove the pidfile for the other
    $self->check_and_create_pidfile()->remove_pid_file;

    my $stage = get_stage();
    if ( $stage == 0 ) {
        Elevate::Logger::ERROR_nolog("Looks like no elevate process was started. Please consider running: /scripts/elevate-cpanel --start");
        return;
    }
    elsif ( $stage == 1 ) {
        Elevate::Logger::INFO_nolog("Continuing elevate process from stage 1 (service not setup yet)");
        $self->run_stage_1();
        return;
    }

    my $pid = fork();
    LOGDIE(qq[Failed to fork: $!]) unless defined $pid;
    if ($pid) {
        Elevate::Logger::INFO_nolog("Restarting install process (stage=$stage)");
        return 1;
    }
    else {
        # when restarting leapp process the restart process can hang for a long time
        #   return earlier to let the user tail the service log
        $self->service->restart;
        exit(0);
    }
}

sub do_cleanup ($self) {

    $self->service->remove;

    $self->ssystem( '/usr/bin/systemctl', 'daemon-reload' );
    unlink ELEVATE_STAGE_FILE;
    unlink Elevate::Constants::PID_FILE;

    unlink Elevate::Blockers::OVH::OVH_MONITORING_TOUCH_FILE;

    Elevate::Motd->cleanup();

    return 0;
}

sub run_service_and_notify ($self) {    # FIXME: move to Elevate::Service - need Notify

    # check it outside the eval block to avoid notification from the command line
    $self->check_and_create_pidfile();

    my $stage = get_stage();

    update_stage_file( { status => q[running] } ) if $stage >= 2;

    my $out;
    my $ok = eval {
        $out = $self->_run_service();
        1;
    };

    if ($ok) {

        # only notify a success when reaching the last stage
        if ( $stage == VALID_STAGES ) {
            update_stage_file( { status => q[success] } );
            $self->_notify_success();
        }

        $self->reboot() if $out == REBOOT_NEEDED;
    }
    else {
        my $error = $@ // q[Unknown error];

        update_stage_file( { status => q[failed] } );
        $self->_notify_error($error);

        LOGDIE($error);
    }

    return $out;
}

sub check_and_create_pidfile ($self) {
    my $upid = Cpanel::PID->new( { pid_file => Elevate::Constants::PID_FILE } );

    if ( $upid->create_pid_file() != 1 ) {
        die qq[Another process is already running. Please wait for it to finish.\n];
    }

    return $upid;
}

sub check_status ($self) {
    my $stage = get_stage();

    if ( !$stage ) {
        Elevate::Logger::ERROR_nolog('Elevation process has not started yet.');
        return;
    }

    my $status = read_stage_file( 'status', 'unknown' );

    if ( $status eq 'success' ) {
        say q[success];
    }
    elsif ( $status eq 'running' ) {
        say qq[Running stage $stage / ] . VALID_STAGES;
    }
    elsif ( $status eq 'failed' ) {
        say qq[Failed during stage $stage];
    }
    else {
        say q[Unknown status];
        return 1;
    }

    return;
}

sub _notify_success ($self) {

    my $pretty_distro_name = $self->upgrade_to_pretty_name();

    my $msg = <<"EOS";
The cPanel & WHM server has completed the elevation process from CentOS 7 to $pretty_distro_name.
EOS

    if ( my $warnings = read_stage_file( 'final_notifications', [] ) ) {
        if ( scalar @$warnings ) {
            $msg .= "\nThe update to $pretty_distro_name was successful but please note that one ore more notifications require your attention:\n";

            foreach my $w ( reverse @$warnings ) {    # restore insert order
                $msg .= "\n* $w\n";
            }
        }
    }

    Elevate::Notify::send_notification( qq[Successfully updated to $pretty_distro_name] => $msg, is_success => 1 );

    return;
}

sub _notify_error ( $self, $error = '' ) {

    my $stage = get_stage();

    my $msg = <<"EOS";
The elevation process failed during stage $stage.

You can continue the process after fixing the errors by running:

    $0 --continue

You can check the error log by running:

    $0

Last Error:

$error

EOS

    my $pretty_distro_name = $self->upgrade_to_pretty_name();
    Elevate::Notify::send_notification( qq[Fail to update to $pretty_distro_name] => $msg );

    return;
}

sub _run_service ($self) {

    my $stage = get_stage();

    print_box( "Starting stage $stage of " . VALID_STAGES ) if $stage > 1;

    # sanity check
    if ( Cpanel::OS::major() == 8 && 2 <= $stage && $stage <= 3 ) {
        WARN( "Detected " . Cpanel::OS::pretty_distro() . " while running stage $stage: swtiching to stage 4" );
        $stage = 4;
        _update_stage_number($stage);
    }

    return $stage == 1
      ? $self->run_stage_1()                                                       # Sanity check & install elevate service
      : $stage == 2 ? $self->run_stage_2()                                         # Update the current distro packages then reboot
      : $stage == 3 ? $self->run_stage_3()                                         # Prep leapp & run leapp process
      : $stage == 4 ? $self->run_stage_4()                                         # reboot on AlmaLinux 8: restore packages
      : $stage == 5 ? $self->run_stage_5()                                         # Final checks and cleanup
      :               die "Unknown stage '$stage'. I don't know how to proceed";

}

sub present_noc_recommendations () {
    local $!;

    my $default_msg = <<~EOS;
    Your server provider has requested that you contact their technical support
    for additional information before you continue with this upgrade process.
    EOS

    my $can_read_file = open( my $fh, '<', NOC_RECOMMENDATIONS_TOUCH_FILE );

    if ( $can_read_file || $! != Errno::ENOENT ) {
        WARN "Provider advisory file potentially present but unable to be opened for reading ($!): using default notice." unless $can_read_file;

        my $msg;
        if ($fh) {
            local $/;
            $msg = <$fh>;
        }
        $msg ||= $default_msg;
        say $msg;

        print "Proceed with the upgrade process? (yes/no) ";
        my $reply = lc <STDIN>;
        chomp $reply;

        if ( $reply !~ m/^y(?:es?)?$/ ) {
            FATAL "Provider recommendations not acknowledged.";
            exit 1;
        }

        INFO "Provider recommendations acknowledged; continuing.";
    }

    close $fh if $fh;
    return 1;
}

=head1 STAGES

Description of the multiple stages used during the elevation process.
Between each stage a reboot is performed before doing a final reboot at the very end.

=head2 run_stage_1

Start the elevation process by installing the elevate-cpanel service
responsible of the multiple reboots.

=cut

sub run_stage_1 ($self) {

    # do not leave cruft behing when aborting
    my $abort = sub {
        $self->do_cleanup();
        exit 42;    ## no critic(Cpanel::NoExitsFromSubroutines) catching signals
    };

    local $SIG{'INT'} = $abort;
    local $SIG{'HUP'} = $abort;

    return 1 unless _sanity_check();

    if ( $self->blockers->check() ) {

        # we have not yet install the service yet, clear the stage file
        $self->service->remove;
        return 1;
    }

    print_box( "Starting stage 1 of " . VALID_STAGES . ": Installing " . $self->service->name . " service" );

    # store 'upgrade_to' early so later stages can access it
    update_stage_file( { upgrade_to => $self->upgrade_to } );

    return $self->service->install();
}

=head2 run_stage_2

Update the current distro packages then reboot.

=cut

sub run_stage_2 ($self) {

    my $sum = `/usr/bin/md5sum $0`;
    chomp $sum;
    DEBUG( sprintf( "Running $0 (%s/%s)", -s $0, $sum ) );

    $self->elevation_startup_marker($sum);

    $self->ssystem(qw{/usr/bin/yum clean all});
    $self->ssystem_and_die(qw{/scripts/update-packages});
    $self->ssystem_and_die(qw{/usr/bin/yum -y update});

    $self->disable_all_cpanel_services();

    $self->setup_outdated_services();

    system touch => CHKSRVD_SUSPEND_FILE;

    Elevate::Motd->setup();

    $self->run_component_once( 'KernelCare' => 'pre_leapp' );
    $self->run_component_once( 'Grub2'      => 'pre_leapp' );

    return REBOOT_NEEDED;
}

=head2 run_stage_3

Setup the AlmaLinux elevate-release-latest-el7 repo and install leapp packages.
Prepare the cPanel packages for the update.

Remove some known conflicting packages. (Reinstall later).

Provide answers to a few leapp questions.

Attempt to perform the leapp upgrade itself.
In case of failure you probably want to reply to a few extra questions or remove some conflicting packages.

=cut

sub run_stage_3 ($self) {

    $self->run_once(
        prep_for_leapp => sub {

            $self->run_once(
                install_pkgs => sub {
                    unless ( Cpanel::Pkgr::is_installed('elevate-release') ) {

                        # provides leapp-data-almalinux & leapp-data-rocky
                        $self->ssystem_and_die(qw{/usr/bin/yum install -y http://repo.almalinux.org/elevate/elevate-release-latest-el7.noarch.rpm});
                    }

                    my $leap_data_pkg = $self->upgrade_to_rocky() ? 'leapp-data-rocky' : 'leapp-data-almalinux';

                    unless ( Cpanel::Pkgr::is_installed('leapp-upgrade') && Cpanel::Pkgr::is_installed($leap_data_pkg) ) {
                        $self->ssystem_and_die( qw{/usr/bin/yum install -y leapp-upgrade }, $leap_data_pkg );
                    }
                    if ( Cpanel::Pkgr::is_installed('kernel-devel') ) {
                        $self->ssystem_and_die(qw{/usr/bin/yum -y remove kernel-devel});
                    }

                    return;
                }
            );

            $self->run_once(
                rmod_ln => sub {
                    $self->ssystem( '/usr/sbin/rmmod', $_ ) foreach qw/floppy pata_acpi/;
                    $self->ssystem(qw{/usr/bin/ln -snf usr/local/cpanel/scripts /scripts});

                    return;
                }
            );

            # We have to do this before removing the rpms.
            $self->run_once('pre_leapp_update_backup_and_cleanup');

            # remove all arch cpanel packages
            # This also potentially removes
            $self->ssystem(q{/usr/bin/rpm -e --justdb --nodeps `/usr/bin/rpm -qa | /usr/bin/egrep '^cpanel-.*\.x86_64'`});

            # remove all ea- packages
            $self->ssystem(q{/usr/bin/yum -y erase ea-*});

            foreach my $rpm (qw/ yum-plugin-fastestmirror epel-release/) {
                next unless Cpanel::Pkgr::is_installed($rpm);
                $self->ssystem( '/usr/bin/rpm', '-e', '--nodeps', $rpm );
            }

            # Avoids having to do preupgrade.
            setup_answer_file();

            return;
        }
    );

    $self->_do_leapp_upgrade();

    WARN(<<'EOS');
Rebooting for distro upgrade. This will take over 10 minutes to run.
Do not interrupt power during this event or you will corrupt your system.
EOS

    return REBOOT_NEEDED;

    # This takes a while because on reboot it's installing 800 packages
}

=head2 run_stage_4

At this stage we should now run Alamalinux 8.
Update cPanel product for the new distro.

Restore removed packages during the previous stage.

=cut

sub run_stage_4 ($self) {
    Cpanel::OS::flush_disk_caches();

    if ( Cpanel::OS::major() != 8 ) {
        my $pretty_distro_name = $self->upgrade_to_pretty_name();
        my $current_distro     = Cpanel::OS::pretty_distro();

        if ( Cpanel::OS::major() == 7 ) {
            WARN("Detected $current_distro from stage 4, reverting back to stage 3.");
            _update_stage_number(3);
        }

        die( <<~"END");
        Server is currently running $current_distro after leapp upgrade.
        Upgrade to $pretty_distro_name did not succeed.

        Please review your upgrade logs and correct the problem.
        `leapp` logs are located at:
            /var/log/leapp/leapp-report.txt
            /var/log/leapp/leapp-report.json

        Once you believe you have corrected the problem you can continue the upgrade process
        by running:
            /scripts/elevate-cpanel --continue
        END
    }

    my $stash = read_stage_file();

    $stash->{stage4} //= {};    # run once each blocks

    $self->run_once(
        sysup => sub {
            Cpanel::Yum::Vars::install();
            $self->ssystem_and_die(qw{/usr/bin/dnf clean all});

            # no failures once already installed: no need to check for the epel-release version
            $self->ssystem_and_die(qw{/usr/bin/dnf -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm});

            $self->ssystem(qw{/usr/bin/rm -f /usr/local/cpanel/3rdparty/bin/perl});
            {
                local $ENV{'CPANEL_BASE_INSTALL'} = 1;    # Don't fix more than perl itself.
                $self->ssystem(qw{/usr/local/cpanel/scripts/fix-cpanel-perl});
            }
            $self->ssystem(qw{/usr/bin/dnf -y --allowerasing update});
            $self->ssystem_and_die(qw{/usr/local/cpanel/scripts/sysup});

            return;
        }
    );

    $self->run_once(
        restore_cpanel_services => sub {
            $self->enable_all_cpanel_services();
            $self->stop_services_before_upcp();
            $self->clear_cpanel_caches();

            return;
        }
    );

    $self->run_component_once( 'EA4' => 'post_leapp' );

    $self->run_once(
        upcp => sub {

            {
                # MySQL server is not upgraded at this point - treat the upcp like a fresh install
                local $ENV{'CPANEL_BASE_INSTALL'} = 1;
                $self->ssystem_and_die(qw{/usr/local/cpanel/scripts/upcp --sync});
            }

            # cleanup the license: cpsanitycheck.so binary is compiled for a different distro
            $self->ssystem(qw{/usr/bin/rm -f /usr/local/cpanel/cpsanitycheck.so});
            $self->ssystem(qw{/usr/local/cpanel/cpkeyclt});

            return;
        }
    );

    $self->post_leapp_update_restore();

    my @known_modules_that_dont_convert = qw{libtermkey msgpack btrfs-progs elevate-release
      leapp leapp-data-almalinux leapp-data-rocky leapp-upgrade-el7toel8
      python2-leapp alt-pcre802 alt-pcre802-devel};
    my @to_remove = grep { Cpanel::Pkgr::is_installed($_) } @known_modules_that_dont_convert;

    INFO("Removing known cruft that various 3rdparties leave behind. Also removing leapp.");
    $self->ssystem( qw{/usr/bin/dnf -y erase}, @to_remove );

    # run upcp a second time as we had to run it before with CPANEL_BASE_INSTALL=1
    $self->run_once(
        upcp_second_run => sub {
            $self->ssystem_and_die(qw{/usr/local/cpanel/scripts/upcp --sync});
        }
    );

    return REBOOT_NEEDED;
}

=head2 run_stage_5

Final checks and cleanup.
The elevate-cpanel service is now removed.

=cut

sub run_stage_5 ($self) {
    return 1 if $self->post_upgrade_check();

    # we cannot stop the service ( ourself )
    $self->service->disable;
    unlink Elevate::Constants::PID_FILE;
    unlink CHKSRVD_SUSPEND_FILE;
    my $el_backup_dir = Elevate::Constants::ELEVATE_BACKUP_DIR;
    File::Path::remove_tree($el_backup_dir) if -d $el_backup_dir;
    Elevate::Motd->cleanup();

    $self->run_component_once( 'Grub2' => 'post_leapp' );

    $self->elevation_success_marker();
    $self->restore_outdated_services();

    INFO("Updating all packages before final reboot");
    $self->ssystem(qw{/usr/bin/dnf -y --allowerasing update});

    $self->_show_final_notifications();

    my $pretty_distro_name = $self->upgrade_to_pretty_name();
    print_box("Great SUCCESS! Your upgrade to $pretty_distro_name is complete.");

    return REBOOT_NEEDED;
}

sub _show_final_notifications ($self) {

    my $final_notifications = read_stage_file( 'final_notifications', [] );
    return unless scalar @$final_notifications;

    print_box("Final Notifications");

    my $final_notice = "The following recommendations should now be reviewed for further action:";

    foreach my $msg ( reverse @$final_notifications ) {
        $final_notice .= "\n$msg\n";
    }
    Elevate::Notify::add_final_notification( $final_notice, 1 );

    return;
}

sub _bq_now () {
    require POSIX;
    return POSIX::strftime( '%FT%T', gmtime );
}

sub elevation_startup_marker ( $self, $sum = 'unknown' ) {

    # store some generic informations about the update process
    update_stage_file(
        {
            '_elevate_process' => {
                script_md5            => $sum,
                cpanel_build          => $Cpanel::Version::Tiny::VERSION_BUILD,
                started_at            => _bq_now(),
                redhat_release_pre    => read_redhat_release(),
                elevate_version_start => VERSION,
            }
        }
    );

    return;
}

sub elevation_success_marker ($self) {

    update_stage_file(
        {
            '_elevate_process' => {
                finished_at            => _bq_now(),
                redhat_release_post    => read_redhat_release(),
                elevate_version_finish => VERSION,
            }
        }
    );

    File::Copy::copy( ELEVATE_STAGE_FILE, ELEVATE_SUCCESS_FILE );

    return;
}

=pod

Example:

    $self->run_component_once( Imunify => 'backup' );

=cut

sub run_component_once ( $self, $name, $function ) {

    my $component = $self->component($name);
    my $label     = "compoment:$name:$function";
    my $sub       = $component->can($function)     #
      or die qq[Missing functon $function from component '$name'];

    my $run = sub {
        return $sub->($component);
    };

    return $self->run_once( $label, $run );
}

sub run_once ( $self, $label, $code = undef ) {

    die unless defined $label;

    $code //= cpev->can($label) or Carp::confess(qq[Missing function '$label']);

    die unless ref $code eq 'CODE';

    my $current_stage = get_stage() // 0;
    my $stage_name    = 'stage' . $current_stage;

    my $stash = read_stage_file();
    $stash->{'_run_once'} //= {};

    my $full_label = $stage_name . '_' . $label;

    # already run one time successfully
    if ( $stash->{'_run_once'}->{$full_label} ) {
        INFO( sprintf( "Stage %d: skipping %s (already run)", $current_stage, $label ) );
        return 1;
    }

    $code->($self);

    # successfully run that block
    update_stage_file( { _run_once => { $full_label => 1 } } );

    return;
}

sub _sanity_check {
    return 1 if -x $0;

    chmod 0700 => $0;

    return 1 if -x $0;

    Elevate::Logger::ERROR_nolog("The script $0 is not executable, please fix it before running it again.");

    return;
}

sub print_box ($message) {

    INFO( "*" x 90 );
    INFO("*");
    INFO("* $message");
    INFO("*");
    INFO( "*" x 90 );

    return;
}

sub setup_outdated_services ($self) {

    my $content = '';

    if ( -e IGNORE_OUTDATED_SERVICES_FILE ) {
        $content = File::Slurper::read_binary(IGNORE_OUTDATED_SERVICES_FILE) // '';
    }

    my $service_name = $self->service->short_name;

    return if $content =~ qr{^${service_name}$}m;

    chomp($content);

    $content .= "\n" if length $content;
    $content .= $service_name . "\n";

    my $dirname = File::Basename::dirname(IGNORE_OUTDATED_SERVICES_FILE);
    if ( !-d $dirname ) {
        mkdir($dirname) or die qq[Fail to create directory $dirname - $!];
    }
    File::Slurper::write_binary( IGNORE_OUTDATED_SERVICES_FILE, $content );

    return 1;
}

sub restore_outdated_services ($self) {

    return unless -e IGNORE_OUTDATED_SERVICES_FILE;

    my $content = File::Slurper::read_binary(IGNORE_OUTDATED_SERVICES_FILE) // '';

    my $service_name = $self->service->short_name;

    if ( $content =~ s{^$service_name$}{}gm ) {
        1 while chomp $content;
        if ( $content =~ m{^\s*\z} ) {
            unlink IGNORE_OUTDATED_SERVICES_FILE;
            return 2;
        }
        else {
            $content .= "\n";
            File::Slurper::write_binary( IGNORE_OUTDATED_SERVICES_FILE, $content );
            return 1;
        }
    }

    return;
}

sub enable_all_cpanel_services ($self) {
    my $services = read_stage_file( 'disabled_cpanel_services', [] );
    unless (@$services) {
        WARN('No cPanel services were disabled!');
    }

    foreach my $service (@$services) {
        $self->ssystem( '/usr/bin/systemctl', 'enable', $service );
        $self->ssystem( '/usr/bin/systemctl', 'stop',   $service );
    }

    return;
}

sub stop_services_before_upcp ($self) {

    # make sure we stop some extra services before updating them

    $self->ssystem(qw{/scripts/restartsrv_tailwatchd --stop});
    $self->ssystem(qw{/scripts/restartsrv_dovecot    --stop});
    $self->ssystem(qw{/scripts/restartsrv_exim       --stop});

    return;
}

sub disable_all_cpanel_services ($self) {

    my @cpanel_services = qw/
      cpanel cpdavd cpgreylistd cphulkd cpipv6
      cpcleartaskqueue
      dnsadmin dovecot exim ipaliases mailman
      mysqld pdns proftpd queueprocd spamd
      crond tailwatchd
      lsws
      /;
    my @disabled_services;

    foreach my $name (@cpanel_services) {
        my $service = Elevate::SystemctlService->new( name => $name );

        next unless $service->is_enabled;
        $service->disable;

        push @disabled_services, $name;
    }
    update_stage_file( { 'disabled_cpanel_services' => [ sort @disabled_services ] } );

    return;
}

sub _do_leapp_upgrade ($self) {

    INFO("Running leapp upgrade");

    my $ok = eval {
        local $ENV{LEAPP_OVL_SIZE} = 3000;
        $self->ssystem_and_die( { keep_env => 1 }, qw{/usr/bin/leapp upgrade} );
        1;
    };

    return 1 if $ok;

    my $msg = <<'EOS';
The 'leapp upgrade' process failed.

Please investigate, resolve then re-run the following command to continue the update:

    /scripts/elevate-cpanel --continue

EOS

    my $leapp_json_report = LEAPP_REPORT_JSON;
    if ( -e $leapp_json_report ) {
        my $report = eval { Cpanel::JSON::LoadFile($leapp_json_report) } // {};

        my $entries = $report->{entries};
        if ( ref $entries eq 'ARRAY' ) {
            foreach my $e (@$entries) {
                next unless ref $e && $e->{title} =~ qr{Missing.*answer}i;

                $msg .= $e->{summary} if $e->{summary};

                if ( ref $e->{detail} ) {
                    my $d = $e->{detail};

                    if ( ref $d->{remediations} ) {
                        foreach my $remed ( $d->{remediations}->@* ) {
                            next unless $remed->{type} && $remed->{type} eq 'command';
                            next unless ref $remed->{context};
                            my @hint = $remed->{context}->@*;
                            next unless scalar @hint;
                            $hint[0] = q[/usr/bin/leapp] if $hint[0] && $hint[0] eq 'leapp';
                            my $cmd = join( ' ', @hint );

                            $msg .= "\n\n";
                            $msg .= <<"EOS";
Consider running this command:

    $cmd
EOS
                        }
                    }

                }

            }
        }
    }

    if ( -e LEAPP_REPORT_TXT ) {
        $msg .= qq[\nYou can read the full leapp report at: ] . LEAPP_REPORT_TXT;
    }

    die qq[$msg\n];
}

# remove and store
sub pre_leapp_update_backup_and_cleanup ($self) {

    $self->run_component_once( 'Imunify'      => 'pre_leapp' );
    $self->run_component_once( 'EA4'          => 'pre_leapp' );
    $self->run_component_once( 'PECL'         => 'pre_leapp' );
    $self->run_component_once( 'MySQL'        => 'pre_leapp' );
    $self->run_component_once( 'Repositories' => 'pre_leapp' );
    $self->run_component_once( 'ArchRPMs'     => 'pre_leapp' );
    $self->run_component_once( 'PerlXS'       => 'pre_leapp' );
    $self->run_component_once( 'Imunify360'   => 'pre_leapp' );
    $self->run_component_once( 'WPToolkit'    => 'pre_leapp' );
    $self->run_component_once( 'InfluxDB'     => 'pre_leapp' );
    $self->run_component_once( 'JetBackup'    => 'pre_leapp' );
    $self->run_component_once( 'NixStats'     => 'pre_leapp' );
    $self->run_component_once( 'LiteSpeed'    => 'pre_leapp' );

    return;
}

sub post_leapp_update_restore ($self) {

    INFO('Removing leapp from excludes in /etc/yum.conf');
    my $txt = eval { File::Slurper::read_text("/etc/yum.conf") };
    if ( length $txt ) {
        $txt =~ s/\s*python2-leapp,snactor,leapp-upgrade-el7toel8,leapp//ms;
        File::Slurper::write_text( "/etc/yum.conf", $txt );
    }

    # plugins can use MySQL - restore database earlier
    $self->run_component_once( 'MySQL'        => 'post_leapp' );
    $self->run_component_once( 'PerlXS'       => 'post_leapp' );
    $self->run_component_once( 'ArchRPMs'     => 'post_leapp' );
    $self->run_component_once( 'PECL'         => 'post_leapp' );
    $self->run_component_once( 'Imunify360'   => 'post_leapp' );
    $self->run_component_once( 'WPToolkit'    => 'post_leapp' );
    $self->run_component_once( 'InfluxDB'     => 'post_leapp' );
    $self->run_component_once( 'JetBackup'    => 'post_leapp' );
    $self->run_component_once( 'Kernel'       => 'post_leapp' );
    $self->run_component_once( 'KernelCare'   => 'post_leapp' );
    $self->run_component_once( 'Imunify'      => 'post_leapp' );
    $self->run_component_once( 'NixStats'     => 'post_leapp' );
    $self->run_component_once( 'LiteSpeed'    => 'post_leapp' );
    $self->run_component_once( 'DigitalOcean' => 'post_leapp' );

    return;
}

sub clear_cpanel_caches ($self) {

    my @dirs = (

        # note: all cpanel users also have a '.cpanel/datastore'
        #       probably not necessary to cleanup
        '/root/.cpanel/datastore',    # cleanup root CachedCommand
    );

    my @files = qw{
      /var/cpanel/GetOS.cache
    };

    foreach my $d (@dirs) {
        $self->ssystem( qw{/usr/bin/rm -rf}, $d );
    }

    unlink $_ foreach @files;

    return;
}

sub tmp_dir ($self) {
    return $self->{tmp} //= File::Temp->newdir();    # auto cleanup on destroy
}

my $yum_list_cache;

sub yum_list ( $invalidate_cache = 0 ) {    # FIXME isolate to its own namespace
    return $yum_list_cache if !$invalidate_cache && $yum_list_cache;

    my @lines = split "\n", Cpanel::SafeRun::Errors::saferunnoerror(qw{/usr/bin/yum list installed});
    while ( my $line = shift @lines ) {
        last if $line && $line =~ m/^Installed Packages/;
    }

    my %repos;
    while ( my $line = shift @lines ) {
        chomp $line;
        my ( $package, $version, $repo ) = split( qr{\s+}, $line );

        if ( !length $version ) {
            my $extra_line = shift @lines;
            chomp $extra_line;
            $extra_line =~ s/^\s+//;
            ( $version, $repo ) = split( ' ', $extra_line );
        }
        if ( !length $repo ) {
            $repo = shift @lines;
            chomp $repo;
            $repo =~ s/\s+//g;
        }
        length $repo or next;    # We screwed up the parse. move on.

        $repo =~ s/^\@// or next;
        $repos{$repo} ||= [];
        next if $repo eq 'installed';    # Not installed from a repo.

        $package =~ s/\.(noarch|x86_64)$//;
        my $arch = $1 // '?';
        push $repos{$repo}->@*, { 'package' => $package, 'version' => $version, arch => $arch };
    }

    return $yum_list_cache = \%repos;
}

sub get_installed_rpms_in_repo (@repo_list) {

    my @to_remove;
    my $installed = yum_list();

    # Regex for repos.
    if ( ref $repo_list[0] eq 'Regexp' ) {
        scalar @repo_list == 1 or Carp::confess("too many args");
        my $regex = shift @repo_list;

        @repo_list = grep { $_ =~ $regex } keys %$installed;
    }

    foreach my $repo (@repo_list) {
        next unless ref $installed->{$repo};
        next unless scalar $installed->{$repo}->@*;
        push @to_remove, map { $_->{'package'} } $installed->{$repo}->@*;
    }

    return @to_remove;
}

sub remove_rpms_from_repos ( $self, @repo_list ) {

    die qq[remove_rpms_from_repos: Not a method call - $self, @repo_list] unless ref $self;

    my @to_remove = get_installed_rpms_in_repo(@repo_list);

    return unless @to_remove;

    INFO( "Removing packages for " . join( ", ", @repo_list ) );

    __PACKAGE__->ssystem( qw{/usr/bin/yum -y erase}, @to_remove );

    return;
}

sub post_upgrade_check ($self) {

    my $expect_distro = $self->upgrade_to_rocky() ? 'rocky' : 'almalinux';

    unless ( Cpanel::OS::major() == 8 && Cpanel::OS::distro() eq $expect_distro ) {
        my $pretty_distro_name = $self->upgrade_to_pretty_name();
        FATAL("Your distro does not looks like $pretty_distro_name.");
        return 1;
    }

    # call a cpanel binary
    $self->ssystem_and_die(qw{/usr/local/cpanel/cpanel -V});

    return 0;
}

sub setup_answer_file {
    my $leapp_dir = '/var/log/leapp';

    mkdir $leapp_dir unless -d $leapp_dir;

    my $leapp_answers = $leapp_dir . '/answerfile.userchoices';

    if ( -f $leapp_answers && -s _ ) {
        warn "Preserve leap answers file: ", $leapp_answers;
        return;
    }

    open( my $fh, '>', $leapp_answers ) or die qq[Fail to setup leapp anserfile.userchoices: $!];
    print {$fh} <<~'EOF';
        [remove_pam_pkcs11_module_check]
        confirm = True
        EOF
    close $fh;

    return;
}

# TODO: We're going to need to store reboot time so we know if the last reboot has happened when we re-run the script.

sub read_stage_file ( $k = undef, $default = {} ) {
    my $stage_info = _read_stage_file() // {};

    return $stage_info->{$k} // $default if defined $k;
    return $stage_info;
}

sub _read_stage_file {    # can be mocked during unit tests
    return eval { Cpanel::JSON::LoadFile(ELEVATE_STAGE_FILE) };
}

sub save_stage_file ($stash) {
    open( my $fh, '>', ELEVATE_STAGE_FILE ) or LOGDIE( "Fail to open " . ELEVATE_STAGE_FILE . ": $!" );
    print {$fh} Cpanel::JSON::pretty_canonical_dump($stash);
    close $fh;

    return 1;
}

sub update_stage_file ($data) {

    die q[Need a hash] unless ref $data eq 'HASH';

    my $current = read_stage_file();
    my $merged  = Hash::Merge::merge( $data, $current );

    return save_stage_file($merged);
}

sub remove_from_stage_file ($key) {
    return unless length $key;

    my $stage = read_stage_file();

    my @list = split( qr/\./, $key );
    return unless scalar @list;

    my $to_delete = pop @list;

    my $h = $stage;
    while ( my $k = shift @list ) {
        $h = $h->{$k};
        last unless ref $h;
    }

    return if scalar @list;
    return unless exists $h->{$to_delete};

    delete $h->{$to_delete};

    return save_stage_file($stage);
}

sub get_stage {
    return read_stage_file( 'stage_number', 0 );
}

sub bump_stage ( $self, $by = 1 ) {

    return _update_stage_number( get_stage() + $by );
}

sub _update_stage_number ($stage_id) {

    if ( $stage_id > 10 ) {    # protection for stage
        require Carp;
        Carp::confess("Invalid stage number $stage_id");
    }

    update_stage_file( { stage_number => $stage_id } );

    return $stage_id;
}

sub reboot ($self) {
    $self->bump_stage();

    # protection
    my $stage = get_stage();

    if ( $stage > VALID_STAGES + 1 ) {
        LOGDIE(qq[Cannot reboot reaching stage $stage]);
    }
    elsif ( $stage <= VALID_STAGES ) {
        print_box( "Rebooting into stage $stage of " . VALID_STAGES );
    }
    else {
        print_box("Doing final reboot");
    }

    if ( request_manual_reboots() ) {
        WARN("Manual Reboot Mode Enabled: please reboot the server to move to the next stage $stage");
        return 0;
    }

    sleep(2);    # ensure display is flushed (using tail...)

    my $exit = $self->ssystem( '/usr/sbin/reboot', 'now' ) or return 0;
    LOGDIE("Failed to reboot system please correct this and reboot");
}

sub request_manual_reboots() {
    return !!read_stage_file( 'manual_reboots', 0 );
}

sub read_redhat_release() {
    my ($first_line) = split( "\n", Cpanel::LoadFile::loadfile('/etc/redhat-release') // '' );

    return $first_line;
}

1;
