#!/usr/local/cpanel/3rdparty/bin/perl

# Copyright 2022 cPanel L.L.C.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.

package cpev;

=encoding utf8

=head1 NAME

/scripts/elevate-cpanel

=head1 DESCRIPTION

Helps to upgrade CentOS 7 cPanel servers to AlmaLinux 8.

=head1 SYNOPSIS

    /scripts/elevate-cpanel [OPTIONS]

    Optional:
       --start                        Start the convertion process
       --continue                     Continue the convertion: retry the last step
       --check                        Check if your system has any known blockers to upgrade.
       --log                          Show the current elevation log
       --status                       Check the current elevation status
       --clean                        Cleanup scripts and files created by elevate-cpanel

       --skip-cpanel-version-check    Skip the check for whether cPanel is up to date.
                                      This option is intended only for testing!

       --help                         Display this documentation.

=head1 COMMON USAGE

=over

=item Start an installation

You can start an elevation update by running:

    /scripts/elevate-cpanel --start

=item Compatibility check with elevation

You can check if your server is compatible with the upgrade process without
starting an upgrade process.

    /scripts/elevate-cpanel --check

=item Start an installation with manual reboot

You can control the reboots by using the --manual-reboots flag when starting the process.
This can be used for debugging purpose.

    /scripts/elevate-cpanel --start --manual-reboots

=item Monitor an existing installation

Once you have started an elevation process, you can check the current update by running:

    /scripts/elevate-cpanel

You can also check the current status by running

    /scripts/elevate-cpanel --status

You can check and monitor the elevation log

    /scripts/elevate-cpanel --log

=item Resume an installation after an error

If an error occurs during the elevation process, once you have fixed it, you can resume
the update process by running:

    /scripts/elevate-cpanel --continue

=back

=head1 WARNINGS

The elevation process from CentOS 7 to Almalinux 8 distribution is not a risk free update.
Depending on the state of your current distribution multiple errors can occur.
We recommend updating your system to the last upstream state before starting.

The elevation process can take several long minutes and requires multiple reboots.
Some reboots are expected to be longer than normal.

Please do not interrupt the reboots and elevation process.

=cut

use cPstrict;

BEGIN {
    # sanity check before loading the script
    eval { require Cpanel::Version::Tiny } or do {
        warn(qq[This script is designed to only run on cPanel servers.\n]);
        exit 1;
    };

    $Cpanel::Version::Tiny::major_version >= 102
      or do {
        warn qq[You need to upgrade your cPanel server to version 102 or later before running this script.\n];
        exit 1;
    }

}

use parent qw( Cpanel::HelpfulScript );

use Log::Log4perl qw(:easy);

use Config;
use Carp           ();
use File::Basename ();
use File::Copy     ();
use File::Find     ();
use File::Path     ();
use File::Slurper  ();
use File::Temp     ();
use Hash::Merge    ();

use Cpanel::Config::Httpd       ();
use Cpanel::Config::LoadCpConf  ();
use Cpanel::HTTP::Client        ();
use Cpanel::JSON                ();
use Cpanel::OS                  ();
use Cpanel::PID                 ();
use Cpanel::Pkgr                ();
use Cpanel::RestartSrv::Systemd ();
use Cpanel::SafeRun::Simple     ();
use Cpanel::SafeRun::Errors     ();
use Cpanel::Update::Tiers       ();
use Cpanel::Version::Tiny       ();
use Cpanel::Version::Compare    ();
use Cpanel::Yum::Vars           ();

use constant CHKSRVD_SUSPEND_FILE => q[/var/run/chkservd.suspend];
use constant ELEVATE_STAGE_FILE   => '/var/cpanel/elevate';
use constant ELEVATE_SUCCESS_FILE => '/var/cpanel/version/elevate';
use constant ELEVATE_BACKUP_DIR   => "/root/.elevate.backup";
use constant SHORT_SERVICE_NAME   => 'elevate-cpanel';
use constant SERVICE_NAME         => SHORT_SERVICE_NAME . '.service';
use constant SERVICE_FILE         => '/etc/systemd/system/' . SERVICE_NAME;
use constant LOG_FILE             => q[/var/log/elevate-cpanel.log];
use constant PID_FILE             => q[/var/run/elevate-cpanel.pid];

use constant VALID_STAGES        => 5;
use constant DISTRO_PERL_XS_PATH => '/usr/local/lib64/perl5';

use constant IGNORE_OUTDATED_SERVICES_FILE => q[/etc/cpanel/local/ignore_outdated_services];

use constant LEAPP_REPORT_JSON => q[/var/log/leapp/leapp-report.json];
use constant LEAPP_REPORT_TXT  => q[/var/log/leapp/leapp-report.txt];

use constant IMUNIFY_AGENT          => '/usr/bin/imunify360-agent';
use constant IMUNIFY_LICENSE_FILE   => '/var/imunify360/license.json';
use constant IMUNIFY_LICENSE_BACKUP => ELEVATE_BACKUP_DIR . '/imunify-backup-license.json';

use constant SBIN_IP => q[/sbin/ip];

use constant YUM_REPOS_D => q[/etc/yum.repos.d];

use constant DISABLE_MYSQL_YUM_REPOS => qw{
  Mysql57.repo
  Mysql80.repo

  MariaDB102.repo
  MariaDB103.repo
  MariaDB105.repo
  MariaDB106.repo
};

use constant VETTED_YUM_REPO => qw{
  CentOS-Base.repo
  CentOS-CR.repo
  CentOS-Debuginfo.repo
  CentOS-fasttrack.repo
  CentOS-Media.repo
  CentOS-Sources.repo
  CentOS-Vault.repo
  CentOS-x86_64-kernel.repo
  cPAddons.repo
  cpanel-plugins.repo
  cp-dev-tools.repo
  EA4.repo
  ELevate.repo
  epel-testing.repo
  epel.repo
  imunify-rollout.repo
  imunify360.repo
  influxdb.repo
  kernelcare.repo
  wp-toolkit-cpanel.repo
  imunify360-ea-php-hardened.repo
  droplet-agent.repo
  }, DISABLE_MYSQL_YUM_REPOS;

use constant REBOOT_NEEDED => 4242;    # just one unique id

sub _OPTIONS {
    return qw( service start clean continue manual-reboots status log check skip-cpanel-version-check );
}

my $logger;

exit( __PACKAGE__->new(@ARGV)->run() // 0 ) if !caller;

sub run ($self) {

    local $| = 1;

    $logger = _init_logger();

    if ( $self->getopt('start') ) {
        die qq[Unsupported option with --start\n] if $self->getopt('continue') || $self->getopt('service');
        return 1                                  if $self->start();
    }
    elsif ( $self->getopt('status') ) {
        return $self->check_status();
    }

    return do_cleanup()      if $self->getopt('clean');
    return $self->do_check() if $self->getopt('check');

    my $stage = get_stage();

    if ( $stage == 0 ) {
        print_box("Please re-run this script with --start if you would like to begin the upgrade process");
        my $out = $self->full_help();
        my ( $short_help, $extra ) = split( qr{^.+STAGES}m, $out );
        chomp $short_help for 1 .. 2;
        say $short_help;
        return 1;
    }

    if ( $self->getopt('start') || $self->getopt('log') ) {
        1;    # these options are exclusive
    }
    elsif ( $self->getopt('continue') ) {
        $self->continue_elevation();
    }
    elsif ( $self->getopt('service') ) {

        # running from the systemct service
        return $self->run_service_and_notify();
    }

    monitor_upgrade();

    return 0;
}

sub monitor_upgrade {
    my $stage = get_stage();

    INFO( "# Monitoring existing upgrade (stage=$stage) process via: tail -f " . LOG_FILE );

    exec( qw{/usr/bin/tail -n40 -F }, LOG_FILE );
}

sub start($self) {
    my $stage = get_stage();
    if ( $stage != 0 ) {
        my $header;
        if ( $stage > VALID_STAGES ) {
            $header = q[The 'elevate-cpanel' script has already been executed on this server.];
        }
        else {
            $header = qq[An elevation process is currently in progress: running stage $stage];
        }

        die <<~"EOS";
        $header
        You can check the log by running:
            /scripts/elevate-cpanel --log
        or check the elevation status:
            /scripts/elevate-cpanel --check
        EOS

    }

    system touch => LOG_FILE;

    bump_stage();    # init stage number to 1

    # store the manual reboots flag
    if ( $self->getopt('manual-reboots') ) {
        WARN('Manual Reboot would be required between each stages');
        update_stage_file( { manual_reboots => 1 } );
    }

    # prefer over running step1: so status and notifications are enabled
    return $self->run_service_and_notify();
}

sub continue_elevation($self) {

    if ( _is_service_active(SERVICE_NAME) ) {
        WARN( "The service " . SERVICE_NAME . " is still running. Please wait for it to finish before restarting it." );
        return;
    }

    # check that no process is running and remove the pidfile for the other
    $self->check_and_create_pidfile()->remove_pid_file;

    my $pid = fork();
    LOGDIE(qq[Failed to fork: $!]) unless defined $pid;
    if ($pid) {
        INFO("Restarting install process");
        return 1;
    }
    else {
        # when restarting leapp process the restart process can hang for a long time
        #   return earlier to let the user tail the service log
        ssystem( qw{/usr/bin/systemctl restart}, SERVICE_NAME );
        exit(0);
    }
}

sub do_cleanup {
    ssystem( '/usr/bin/systemctl', 'stop',    SERVICE_NAME );
    ssystem( '/usr/bin/systemctl', 'disable', SERVICE_NAME );
    unlink SERVICE_FILE;

    ssystem( '/usr/bin/systemctl', 'daemon-reload' );
    unlink ELEVATE_STAGE_FILE;
    unlink PID_FILE;

    cleanup_motd();

    return 0;
}

sub run_service_and_notify($self) {

    # check it outside the eval block to avoid notification from the command line
    $self->check_and_create_pidfile();

    my $stage = get_stage();

    update_stage_file( { status => q[running] } ) if $stage >= 2;

    my $out;
    my $ok = eval {
        $out = $self->_run_service();
        1;
    };

    if ($ok) {

        # only notify a success when reaching the last stage
        if ( $stage == VALID_STAGES ) {
            update_stage_file( { status => q[success] } );
            $self->_notify_success();
        }

        reboot() if $out == REBOOT_NEEDED;
    }
    else {
        my $error = $@ // q[Unknown error];

        update_stage_file( { status => q[failed] } );
        $self->_notify_error($error);

        LOGDIE($error);
    }

    return $out;
}

sub check_and_create_pidfile($self) {
    my $upid = Cpanel::PID->new( { pid_file => PID_FILE } );

    if ( $upid->create_pid_file() != 1 ) {
        die qq[Another process is already running. Please wait for it to finish.\n];
    }

    return $upid;
}

sub check_status($self) {
    my $stage = get_stage();

    if ( !$stage ) {
        ERROR('Elevation process has not started yet.');
        return;
    }

    my $stage_info = read_stage_file();

    my $status = $stage_info->{status} // 'unknown';

    if ( $status eq 'success' ) {
        say q[success];
    }
    elsif ( $status eq 'running' ) {
        say qq[Running stage $stage / ] . VALID_STAGES;
    }
    elsif ( $status eq 'failed' ) {
        say qq[Failed during stage $stage];
    }
    else {
        say q[Unknown status];
        return 1;
    }

    return;
}

sub _notify_success($self) {

    my $msg = <<'EOS';
The cPanel & WHM server has completed the elevation process from CentOS 7 to AlmaLinux 8.
EOS

    send_notification( 'Successfully update to AlmaLinux 8' => $msg );

    return;
}

sub _notify_error ( $self, $error = '' ) {

    my $stage = get_stage();

    my $msg = <<"EOS";
The elevation process failed during stage $stage.

You can continue the process after fixing the errors by running:

    $0 --continue

You can check the error log by running:

    $0

Last Error:

$error

EOS

    send_notification( 'Fail to update to AlmaLinux 8' => $msg );

    return;
}

sub send_notification ( $subject, $msg ) {

    eval {
        _send_notification( $subject, $msg );
        1;
    }
      or warn "Fail to send notification: $@";

    return;
}

sub _send_notification ( $subject, $msg ) {

    # note: no need to use one iContact::Class this is a one shot message
    require Cpanel::iContact;

    ERROR("Sending notification: $subject");
    ERROR($msg);

    Cpanel::iContact::icontact(
        'application' => 'elevate',
        'subject'     => $subject,
        'message'     => $msg,
    );

    return;
}

sub _run_service($self) {

    my $stage = get_stage();

    print_box( "Starting stage $stage of " . VALID_STAGES ) if $stage > 1;

    return
        $stage == 1 ? $self->run_stage_1()
      : $stage == 2 ? $self->run_stage_2()
      : $stage == 3 ? $self->run_stage_3()
      : $stage == 4 ? $self->run_stage_4()
      : $stage == 5 ? $self->run_stage_5()
      :               die "Unknown stage '$stage'. I don't know how to proceed";

}

sub do_check($self) {

    if ( _is_service_active(SERVICE_NAME) ) {
        WARN("An elevation process is already in progress.");
        return 1;
    }

    my $has_blockers = $self->blockers_check(1);

    # cleanup the stage file
    unlink ELEVATE_STAGE_FILE;

    if ($has_blockers) {
        WARN( <<~'EOS' );
        Please fix the detected issues before performing the elevation process.
        EOS
    }
    else {
        INFO( <<~'EOS' );
        There is no known blockers to start the elevation process.
        You can consider running:
            /scripts/elevate-cpanel --start
        EOS
    }

    return $has_blockers;
}

=head1 STAGES

Description of the multiple stages used during the elevation process.
Between each stage a reboot is performed before doing a final reboot at the very end.

=head2 run_stage_1

Start the elevation process by installing the elevate-cpanel service
responsible of the multiple reboots.

=cut

sub run_stage_1($self) {

    # do not leave cruft behing when aborting
    my $abort = sub {
        do_cleanup();
        exit 42;    ## no critic(Cpanel::NoExitsFromSubroutines) catching signals
    };

    local $SIG{'INT'} = $abort;
    local $SIG{'HUP'} = $abort;

    return 1 unless _sanity_check();

    if ( $self->blockers_check() ) {

        # we have not yet install the service yet, clear the stage file
        unlink ELEVATE_STAGE_FILE;
        return 1;
    }

    print_box(q[/!\ Warning: You are about to convert your cPanel & WHM CentOS 7 to Almalinux 8 server.]);

    say <<'EOS';

The elevation process can take several long minutes and requires multiple reboots.
Some reboots can be longer than normal, please do not interrupt the process.

Please *do not interrupt* the reboots and elevation process.

You can check at any time the current status of the update by running:

    /scripts/elevate-cpanel

On failures after fixing them you can continue the elevation process by running:

    /scripts/elevate-cpanel --continue

EOS

    _do_warn_skip_version_check() if $self->getopt('skip-cpanel-version-check');    # give one last reminder

    say <<EOS;
This is your chance now to cancel the update process.
You can hit CTRL-C to abort, otherwise the install starts in a few seconds.
EOS

    do { sleep 1; print '.' }
      for 1 .. 6;
    print "\n";

    print_box( "Starting stage 1 of " . VALID_STAGES . ": Installing " . SERVICE_NAME . " service" );
    return install_cpanel_elevate_service();
}

=head2 run_stage_2

Update the current distro packages then reboot.

=cut

sub run_stage_2($self) {

    my $sum = `/usr/bin/md5sum $0`;
    chomp $sum;
    DEBUG( sprintf( "Running $0 (%s/%s)", -S $0, $sum ) );

    $self->elevation_startup_marker($sum);

    ssystem(qw{/usr/bin/yum clean all});
    ssystem_and_die(qw{/scripts/update-packages});
    ssystem_and_die(qw{/usr/bin/yum -y update});

    disable_known_yum_repositories();

    disable_all_cpanel_services();

    setup_outdated_services();

    system touch => CHKSRVD_SUSPEND_FILE;

    setup_motd();

    run_once('remove_kernelcare_if_needed');

    return REBOOT_NEEDED;
}

=head2 run_stage_3

Setup the Alamlinux elevate-release-latest-el7 repo and install leapp packages.
Prepare the cPanel packages for the update.

Remove some known conflicting packages. (Reinstall later).

Provide answers to a few leapp questions.

Attempt to perform the leapp upgrade itself.
In case of failure you probably want to reply to a few extra questions or remove some conflictiong packages.

=cut

sub run_stage_3($self) {

    run_once(
        prep_for_leapp => sub {

            run_once(
                install_pkgs => sub {
                    unless ( Cpanel::Pkgr::is_installed('elevate-release') ) {
                        ssystem_and_die(qw{/usr/bin/yum install -y http://repo.almalinux.org/elevate/elevate-release-latest-el7.noarch.rpm});
                    }

                    unless ( Cpanel::Pkgr::is_installed('leapp-upgrade') && Cpanel::Pkgr::is_installed('leapp-data-almalinux') ) {
                        ssystem_and_die(qw{/usr/bin/yum install -y leapp-upgrade leapp-data-almalinux});
                    }
                    if ( Cpanel::Pkgr::is_installed('kernel-devel') ) {
                        ssystem_and_die(qw{/usr/bin/yum -y remove kernel-devel});
                    }

                    return;
                }
            );

            run_once(
                rmod_ln => sub {
                    ssystem( '/usr/sbin/rmmod', $_ ) foreach qw/floppy pata_acpi/;
                    ssystem(qw{/usr/bin/ln -snf usr/local/cpanel/scripts /scripts});

                    return;
                }
            );

            # We have to do this before removing the rpms.
            run_once('pre_leapp_update_backup_and_cleanup');

            # remove all arch cpanel packages
            # This also potentially removes
            ssystem(q{/usr/bin/rpm -e --justdb --nodeps `/usr/bin/rpm -qa | /usr/bin/egrep '^cpanel-.*\.x86_64'`});

            # remove all ea- packages
            ssystem(q{/usr/bin/yum -y erase ea-*});

            foreach my $rpm (qw/ yum-plugin-fastestmirror epel-release/) {
                next unless Cpanel::Pkgr::is_installed($rpm);
                ssystem( '/usr/bin/rpm', '-e', '--nodeps', $rpm );
            }

            # Avoids having to do preupgrade.
            setup_answer_file();

            return;
        }
    );

    _do_leapp_upgrade();

    WARN(<<'EOS');
Rebooting for distro upgrade. This will take over 10 minutes to run.
Do not interrupt power during this event or you will corrupt your system.
EOS

    return REBOOT_NEEDED;

    # This takes a while because on reboot it's installing 800 packages
}

=head2 run_stage_4

At this stage we should now run Alamalinux 8.
Update cPanel product for the new distro.

Restore removed packages during the previous stage.

=cut

sub run_stage_4($self) {
    Cpanel::OS::flush_disk_caches();
    Cpanel::OS::major() == 8 or die("Upgrade to AlmaLinux 8 did not succeed. Please restore from backup.");

    my $stash = read_stage_file();

    $stash->{stage4} //= {};    # run once each blocks

    run_once(
        sysup => sub {
            Cpanel::Yum::Vars::install();
            ssystem_and_die(qw{/usr/bin/dnf clean all});

            # no failures once already installed: no need to check for the epel-release version
            ssystem_and_die(qw{/usr/bin/dnf -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm});

            ssystem(qw{/usr/bin/rm -f /usr/local/cpanel/3rdparty/bin/perl});
            {
                local $ENV{'CPANEL_BASE_INSTALL'} = 1;    # Don't fix more than perl itself.
                ssystem(qw{/usr/local/cpanel/scripts/fix-cpanel-perl});
            }
            ssystem(qw{/usr/bin/dnf -y --allowerasing update});
            ssystem_and_die(qw{/usr/local/cpanel/scripts/sysup});

            return;
        }
    );

    run_once(
        restore_cpanel_services => sub {
            enable_all_cpanel_services();
            stop_services_before_upcp();
            clear_cpanel_caches();

            return;
        }
    );

    run_once('restore_ea4_profile');
    run_once('restore_ea_addons');

    run_once(
        upcp => sub {

            {
                # MySQL server is not upgraded at this point - treat the upcp like a fresh install
                local $ENV{'CPANEL_BASE_INSTALL'} = 1;
                ssystem_and_die(qw{/usr/local/cpanel/scripts/upcp --sync});
            }

            # cleanup the license: cpsanitycheck.so binary is compiled for a different distro
            ssystem(qw{/usr/bin/rm -f /usr/local/cpanel/cpsanitycheck.so});
            ssystem(qw{/usr/local/cpanel/cpkeyclt});

            return;
        }
    );

    post_leapp_update_restore();

    my @known_modules_that_dont_convert = qw{libtermkey msgpack btrfs-progs elevate-release
      leapp leapp-data-almalinux leapp-upgrade-el7toel8 python2-leapp alt-pcre802 alt-pcre802-devel};
    my @to_remove = grep { Cpanel::Pkgr::is_installed($_) } @known_modules_that_dont_convert;

    INFO("Removing known cruft that various 3rdparties leave behind. Also removing leapp.");
    ssystem( qw{/usr/bin/dnf -y erase}, @to_remove );

    # run upcp a second time as we had to run it before with CPANEL_BASE_INSTALL=1
    run_once(
        upcp_second_run => sub {
            ssystem_and_die(qw{/usr/local/cpanel/scripts/upcp --sync});
        }
    );

    return REBOOT_NEEDED;
}

=head2 run_stage_5

Final checks and cleanup.
The elevate-cpanel service is now removed.

=cut

sub run_stage_5($self) {
    return 1 if post_upgrade_check();

    # we cannot stop the service ( ourself )
    ssystem( '/usr/bin/systemctl', 'disable', SERVICE_NAME );
    unlink SERVICE_FILE;
    unlink PID_FILE;
    unlink CHKSRVD_SUSPEND_FILE;
    File::Path::remove_tree(ELEVATE_BACKUP_DIR) if -d ELEVATE_BACKUP_DIR;
    cleanup_motd();

    my $postinstall_recommendations = read_stage_file()->{'a_postinstall_recommendation'} // [];
    if (@$postinstall_recommendations) {

        print_box("The following recommendations should now be reviewed for further action:");
        foreach my $msg (@$postinstall_recommendations) {
            WARN("$msg");
        }
    }

    $self->elevation_success_marker();

    restore_outdated_services();

    INFO("Updating all packages before final reboot");
    ssystem(qw{/usr/bin/dnf -y --allowerasing update});

    print_box("Great SUCCESS! Your upgrade to AlmaLinux 8 is complete.");

    return REBOOT_NEEDED;
}

sub elevation_startup_marker ( $self, $sum = 'unknown' ) {

    # store some generic informations about the update process
    update_stage_file(
        {
            '_elevate_process' => {
                script_md5         => $sum,
                cpanel_build       => $Cpanel::Version::Tiny::VERSION_BUILD,
                started_at         => scalar gmtime(),
                redhat_release_pre => read_redhat_release(),
            }
        }
    );

    return;
}

sub elevation_success_marker($self) {

    update_stage_file(
        {
            '_elevate_process' => {
                finished_at         => scalar gmtime(),
                redhat_release_post => read_redhat_release(),
            }
        }
    );

    File::Copy::copy( ELEVATE_STAGE_FILE, ELEVATE_SUCCESS_FILE );

    return;
}

sub run_once ( $label, $code = undef ) {

    die unless defined $label;

    $code //= cpev->can($label) or die qq[Missing function '$label'];

    die unless ref $code eq 'CODE';

    my $current_stage = get_stage() or die q[Unknown stage id];
    my $stage_name    = 'stage' . $current_stage;

    my $stash = read_stage_file();
    $stash->{'_run_once'} //= {};

    my $full_label = $current_stage . '_' . $label;

    # already run one time successfully
    if ( $stash->{'_run_once'}->{$full_label} ) {
        INFO( sprintf( "Stage %d: skipping %s (already run)", $current_stage, $label ) );
        return 1;
    }

    $code->();

    # successfully run that block
    update_stage_file( { _run_once => { $full_label => 1 } } );

    return;
}

sub capture_imunify_features {
    -x IMUNIFY_AGENT or return;

    my $output   = Cpanel::SafeRun::Simple::saferunnoerror( IMUNIFY_AGENT, qw{features list} );
    my @features = map { s/\s+//g; $_ } grep { m/\S/ } split( "\n", $output );

    if ( -f IMUNIFY_LICENSE_FILE ) {
        File::Copy::move( IMUNIFY_LICENSE_FILE, IMUNIFY_LICENSE_BACKUP );
    }

    update_stage_file( { 'reinstall' => { 'imunify_features' => \@features } } );

    return;
}

sub restore_imunify_features {
    File::Copy::move( IMUNIFY_LICENSE_BACKUP, IMUNIFY_LICENSE_FILE ) if -f IMUNIFY_LICENSE_BACKUP;

    return unless my $features = read_stage_file()->{'reinstall'}->{'imunify_features'};
    return unless ref $features eq 'ARRAY';
    return unless @$features;

    INFO("Restoring imunify 360 features.");
    foreach my $feature (@$features) {
        INFO("Restoring imunify360 $feature");
        my $log_file = Cpanel::SafeRun::Simple::saferunnoerror( IMUNIFY_AGENT, qw{features install }, $feature );
        $log_file or next;
        chomp $log_file;
        next unless $log_file =~ m/\S/;

        monitor_imunify_feature_install( $feature, $log_file );
    }

    return;
}

sub imunify_feature_install_status ($feature) {
    my $install_status = eval {
        my $json = Cpanel::SafeRun::Simple::saferunnoerror( IMUNIFY_AGENT, qw{features status}, $feature, '--json' ) // '{}';
        Cpanel::JSON::Load($json);
    } // {};

    my $status = $install_status->{'items'}->{'status'} // '';

    return $status if $status =~ m/^(installed|installing|not_installed)$/i;
    return $install_status->{'items'}->{'message'} || "$feature is unknown";
}

# Wait 20 mins for the pid to finish.
sub monitor_imunify_feature_install ( $feature, $log_file ) {

    my $start = time;
    while ( time - $start < 30 ) {
        my $status = imunify_feature_install_status($feature);
        last if ( $status eq 'installed' || $status eq 'installing' && -e $log_file );
    }

    open( my $fh, '<', $log_file ) or do {
        my $status = imunify_feature_install_status($feature);
        WARN("Could not open $log_file for monitoring ($!). The install of $feature is in state: $status");
        return;
    };

    DEBUG("Monitoring $log_file for completion");

    # Tail the log file and monitor status of the install by making agent queries.
    $start = time;
    my $partial_line = '';
    while ( time - $start < 60 * 20 ) {    # abort after 20 minutes.

        # Tail the file for new information.
        while ( my $read = <$fh> ) {
            my $partial_line .= $read;
            if ( length $read && substr( $partial_line, -1, 1 ) eq "\n" ) {
                INFO($partial_line);
                $partial_line = '';
            }
        }

        # This takes 1.5 seconds to query every time.
        my $status = imunify_feature_install_status($feature);
        if ( $status eq 'installed' ) {
            INFO("Restore of $feature complete.");
            return 1;
        }
        if ( $status ne 'installing' ) {
            FATAL("Failed to install immuinfy 360 feature $feature ($status)");
            FATAL("See $log_file for more information");
            return 0;
        }

        sleep 5;
    }

    WARN("Imunify failed to install feature $feature");
    return 0;
}

sub remove_kernelcare_if_needed {

    return unless -x q[/usr/bin/kcarectl];

    # This environment variable signals to the KernelCare RPM scriptlets not to deregister on package removal.
    local $ENV{KCARE_KEEP_REGISTRATION} = '1';
    remove_rpms_from_repos('kernelcare');

    update_stage_file( { 'reinstall' => { 'kernelcare' => 1 } } );

    return 1;
}

sub restore_kernel_care {
    return unless read_stage_file()->{'reinstall'}->{'kernelcare'};

    INFO("Restoring kernelcare");

    INFO("Retrieving kernelcare installer");
    my $installer_script = _fetch_a_script( 'https://kernelcare.com/installer', 'kernelcare_installer' );

    my $conf_file = q[/etc/sysconfig/kcare/kcare.conf];
    if ( -e $conf_file . q[.rpmsave] ) {
        INFO("Restoring Configuration file: $conf_file");

        # restore configuration file before installing it
        File::Copy::copy( $conf_file . q[.rpmsave], $conf_file );
    }

    INFO("Running kernelcare installer");
    ssystem_and_die( '/usr/bin/bash' => $installer_script );

    unlink $installer_script;

    INFO("Updating kernelcare");
    ssystem(qw{ /usr/bin/kcarectl --update });

    return;
}

sub _motd_notice_message {
    return <<~'EOS';
    # -----------------------------------------------------------------------------
    #
    # /!\ ELEVATE IN PROGRESS /!\
    #
    # Do not make any changes until it's complete
    # you can check the current process status by running:
    #
    #           /scripts/elevate-cpanel --status
    #
    # Or monitor the progress by running:
    #
    #           /scripts/elevate-cpanel --log
    #
    # -----------------------------------------------------------------------------
    EOS
}

sub _motd_file {    # allow us to mock it, we cannot use Test::MockFile GH #77 - https://github.com/cpanel/Test-MockFile/issues/77
    return q[/etc/motd];
}

sub setup_motd {

    my $f = _motd_file();

    my $notice = _motd_notice_message();

    local $/;
    my $fh;
    my $content = '';

    if ( open( $fh, '+<', $f ) ) {
        $content = <$fh> // '';
    }
    elsif ( open( $fh, '>', $f ) ) {
        1;
    }

    return 0 if $content =~ qr{elevate in progress}mi;

    print {$fh} "\n" if length($content) && $content !~ qr{\n\z};

    print {$fh} $notice;

    return 1;
}

sub cleanup_motd {

    my $f = _motd_file();

    my $content;
    open( my $fh, '+<', $f ) or return;
    {
        local $/;
        $content = <$fh>;
    }

    return 0 unless $content && $content =~ qr{elevate in progress}mi;

    my $notice = _motd_notice_message();

    if ( $content =~ s{\Q$notice\E}{} ) {
        seek( $fh, 0, 0 );
        print {$fh} $content;
        truncate( $fh, tell($fh) );
        close($fh);

        return 1;
    }

    return;
}

sub _sanity_check {
    return 1 if -x $0;

    chmod 0700 => $0;

    return 1 if -x $0;

    ERROR("The script $0 is not executable, please fix it before running it again.");

    return;
}

sub print_box ($message) {

    INFO( "*" x 90 );
    INFO("*");
    INFO("* $message");
    INFO("*");
    INFO( "*" x 90 );

    return;
}

sub setup_outdated_services {

    my $content = '';

    if ( -e IGNORE_OUTDATED_SERVICES_FILE ) {
        $content = File::Slurper::read_binary(IGNORE_OUTDATED_SERVICES_FILE) // '';
    }

    my $service_name = SHORT_SERVICE_NAME;

    return if $content =~ qr{^${service_name}$}m;

    chomp($content);

    $content .= "\n" if length $content;
    $content .= $service_name . "\n";

    my $dirname = File::Basename::dirname(IGNORE_OUTDATED_SERVICES_FILE);
    if ( !-d $dirname ) {
        mkdir($dirname) or die qq[Fail to create directory $dirname - $!];
    }
    File::Slurper::write_binary( IGNORE_OUTDATED_SERVICES_FILE, $content );

    return 1;
}

sub restore_outdated_services {

    return unless -e IGNORE_OUTDATED_SERVICES_FILE;

    my $content = File::Slurper::read_binary(IGNORE_OUTDATED_SERVICES_FILE) // '';

    my $service_name = SHORT_SERVICE_NAME;

    if ( $content =~ s{^$service_name$}{}gm ) {
        1 while chomp $content;
        if ( $content =~ m{^\s*\z} ) {
            unlink IGNORE_OUTDATED_SERVICES_FILE;
            return 2;
        }
        else {
            $content .= "\n";
            File::Slurper::write_binary( IGNORE_OUTDATED_SERVICES_FILE, $content );
            return 1;
        }
    }

    return;
}

sub enable_all_cpanel_services {
    my $services = read_stage_file()->{'disabled_cpanel_services'} // [];
    unless (@$services) {
        WARN('No cPanel services were disabled!');
    }

    foreach my $service (@$services) {
        ssystem( '/usr/bin/systemctl', 'enable', $service );
        ssystem( '/usr/bin/systemctl', 'stop',   $service );
    }

    return;
}

sub stop_services_before_upcp {

    # make sure we stop some extra services before updating them

    ssystem(qw{/scripts/restartsrv_tailwatchd --stop});
    ssystem(qw{/scripts/restartsrv_dovecot    --stop});
    ssystem(qw{/scripts/restartsrv_exim       --stop});

    return;
}

sub disable_all_cpanel_services {

    my @cpanel_services = qw/
      cpanel cpdavd cpgreylistd cphulkd cpipv6
      cpcleartaskqueue
      dnsadmin dovecot exim ipaliases mailman
      mysqld pdns proftpd queueprocd spamd
      crond tailwatchd
      lsws
      /;
    my @disabled_services;

    foreach my $service (@cpanel_services) {
        next unless _is_service_enabled($service);

        ssystem( qw{/usr/bin/systemctl disable --now}, $service );
        push @disabled_services, $service;
    }
    update_stage_file( { 'disabled_cpanel_services' => [ sort @disabled_services ] } );

    return;
}

sub disable_known_yum_repositories {

    # remove all MySQL repos
    my @repo_files = map { YUM_REPOS_D . '/' . $_ } DISABLE_MYSQL_YUM_REPOS;

    foreach my $f (@repo_files) {
        next unless -e $f;
        if ( -l $f ) {
            unlink $f;
            next;
        }

        File::Copy::move( $f, "$f.off" ) or die qq[Fail to disable repo $f];
    }

    Cpanel::SafeRun::Simple::saferunnoerror(qw{/usr/bin/yum clean all});

    return;
}

sub _is_service_active( $service ) {

    # cannot trust: `systemctl is-active` with a one-shot service

    my $is_active;
    Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/bin/systemctl is-active}, $service );
    $is_active = 1 if $? == 0;

    my $info = Cpanel::RestartSrv::Systemd::get_service_info_via_systemd($service);
    $info->{'ActiveState'} //= '';
    $info->{'SubState'}    //= '';

    $is_active = 1 if $info->{'ActiveState'} eq 'activating' && $info->{'SubState'} eq 'start';

    if ( $is_active && $info->{'SubState'} ne 'exited' ) {
        return 1;
    }

    return 0;
}

sub _is_service_enabled( $service ) {

    my $out = Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/bin/systemctl is-enabled}, $service ) // '';

    chomp $out;

    return 1 if $out eq 'enabled';

    return 0;
}

sub restore_ea4_profile () {

    my $stash      = read_stage_file();
    my $is_enabled = $stash->{'ea4'}->{'enable'};

    unless ($is_enabled) {
        WARN('Skipping EA4 restore. EA4 does not appear to be enabled on this system');
        return;
    }

    my $json = $stash->{'ea4'}->{'profile'};
    unless ( length $json && -f $json && -s _ ) {
        WARN('Unable to restore EA4 profile. Is EA4 enabled?');
        INFO("Profile was backed up as: $json") if length $json;
        return;
    }

    ssystem( '/usr/local/bin/ea_install_profile', '--install', $json );

    return;
}

sub restore_ea_addons () {

    my $stash       = read_stage_file();
    my $needs_nginx = $stash->{'ea4'}->{'nginx'};

    if ($needs_nginx) {
        INFO("Restoring ea-nginx");

        # ea profile restore it in a broken state - remove & reinstall
        ssystem(qw{/usr/bin/rpm -e --nodeps ea-nginx});
        ssystem_and_die(qw{/usr/bin/yum install -y ea-nginx});
    }

    return;
}

sub backup_ea4_profile () {

    my $use_ea4 = Cpanel::Config::Httpd::is_ea4() ? 1 : 0;
    update_stage_file( { ea4 => { enable => $use_ea4 } } );

    unless ($use_ea4) {
        WARN('Skipping EA4 backup. EA4 does not appear to be enabled on this system');

        return;
    }

    my @cmd     = qw{ /usr/local/bin/ea_current_to_profile --target-os=AlmaLinux_8};
    my $cmd_str = join( ' ', @cmd );
    INFO("Running: $cmd_str");
    my $json = Cpanel::SafeRun::Simple::saferunnoerror(@cmd) // '';
    die qq[Failure from $cmd_str] if $?;

    chomp $json;
    die "Unable to backup EA4 profile to $json" unless length $json && -f $json && -s _;
    INFO("Backed up EA4 profile to $json");

    update_stage_file( { ea4 => { profile => $json } } );

    return;
}

sub backup_ea_addons() {

    if ( Cpanel::Pkgr::is_installed('ea-nginx') ) {
        update_stage_file( { ea4 => { nginx => 1 } } );
    }

    return;
}

sub _do_leapp_upgrade {

    INFO("Running leapp upgrade");

    my $ok = eval {
        ssystem_and_die(qw{/usr/bin/leapp upgrade});
        1;
    };

    return 1 if $ok;

    my $msg = <<'EOS';
The 'leapp upgrade' process failed.

Please investigate, resolve then re-run the following command to continue the update:

    /scripts/elevate-cpanel --continue

EOS

    my $leapp_json_report = LEAPP_REPORT_JSON;
    if ( -e $leapp_json_report ) {
        my $report = eval { Cpanel::JSON::LoadFile($leapp_json_report) } // {};

        my $entries = $report->{entries};
        if ( ref $entries eq 'ARRAY' ) {
            foreach my $e (@$entries) {
                next unless ref $e && $e->{title} =~ qr{Missing.*answer}i;

                $msg .= $e->{summary} if $e->{summary};

                if ( ref $e->{detail} ) {
                    my $d = $e->{detail};

                    if ( ref $d->{remediations} ) {
                        foreach my $remed ( $d->{remediations}->@* ) {
                            next unless $remed->{type} && $remed->{type} eq 'command';
                            next unless ref $remed->{context};
                            my @hint = $remed->{context}->@*;
                            next unless scalar @hint;
                            $hint[0] = q[/usr/bin/leapp] if $hint[0] && $hint[0] eq 'leapp';
                            my $cmd = join( ' ', @hint );

                            $msg .= "\n\n";
                            $msg .= <<"EOS";
Consider running this command:

    $cmd
EOS
                        }
                    }

                }

            }
        }
    }

    if ( -e LEAPP_REPORT_TXT ) {
        $msg .= qq[\nYou can read the full leapp report at: ] . LEAPP_REPORT_TXT;
    }

    die qq[$msg\n];
}

# remove and store
sub pre_leapp_update_backup_and_cleanup {

    run_once('capture_imunify_features');
    run_once('backup_ea4_profile');
    run_once('backup_ea_addons');
    run_once('backup_pecl_packages');
    run_once('cleanup_mysql_packages');

    run_once(
        arch_rpms => sub {

            # Backup arch rpms which we're going to remove and are provided by yum.
            my @installed_arch_cpanel_plugins;

            my $installed    = yum_list();
            my @cpanel_repos = grep { m/^cpanel-/ } keys %$installed;
            foreach my $repo (@cpanel_repos) {
                push @installed_arch_cpanel_plugins, map { $_->{'package'} } $installed->{$repo}->@*;
            }

            update_stage_file( { restore => { yum => \@installed_arch_cpanel_plugins } } ) if @installed_arch_cpanel_plugins;
            return;
        }
    );

    purge_perl_xs(DISTRO_PERL_XS_PATH);
    purge_perl_xs( $Config{'installsitearch'} );

    run_once('remove_imunify_360');
    run_once('remove_wordpress_toolkit');
    run_once('remove_influxdb');
    run_once('remove_jetbackup');
    run_once('remove_nixstats');
    run_once('pre_install_check_litespeed');

    return;
}

sub cleanup_mysql_packages {

    my $stash = read_stage_file();

    my $mysql_version = $stash->{'mysql-version'};
    return unless length $mysql_version;

    INFO("# Cleanup MySQL packages ; using version $mysql_version");

    update_stage_file( { 'mysql-version' => $mysql_version } );

    # make sure all packages from unsupported repo are removed
    #
    # we cannot only remove the packages for the current MySQL versions
    # some packages can also installed from other repo

    cleanup_mysql_57_packages();
    cleanup_mysql_80_packages();
    cleanup_mysql_102_packages();
    cleanup_mysql_103_packages();
    cleanup_mysql_105_packages();
    cleanup_mysql_106_packages();

    return;
}

sub reinstall_mysql_packages {
    my $stash = read_stage_file();

    my $mysql_version = $stash->{'mysql-version'} or return;

    INFO("Restoring MySQL $mysql_version");

    my ( $major, $minor ) = split( /\./, $mysql_version );

    # ensure the repo package is available for MySQL / MariaDB
    # my $repopkg = $major >= 10 ? q[Cpanel::MariaDB::Install] : q[Cpanel::Mysql::Install];
    # Cpanel::SafeRun::Simple::saferunnoerror( $^X, "-M$repopkg", '-E', "$repopkg->new->install_repo( q[$mysql_version] )" );
    # WARN(qq[Fail to install repo for $mysql_version using $repopkg]) if $?;

    my $out = Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/local/cpanel/bin/whmapi1 start_background_mysql_upgrade}, "version=$mysql_version" );
    die qq[Fail to restore MySQL $mysql_version] if $?;

    if ( $out =~ m{\supgrade_id:\s*(\S+)} ) {
        my $id = $1;

        INFO("Restoring MySQL via upgrade_id $id");
        INFO('Waiting for MySQL installation');

        my $status = '';

        my $c = 0;

        while (1) {
            $c = ( $c + 1 ) % 10;
            my $out = Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/local/cpanel/bin/whmapi1 background_mysql_upgrade_status }, "upgrade_id=$id" );
            die qq[Fail to restore MySQL $mysql_version: cannot check upgrade_id=$id] if $?;

            if ( $out =~ m{\sstate:\s*inprogress} ) {
                print ".";
                print "\n" if $c == 0;
                sleep 5;
                next;
            }

            if ( $out =~ m{\sstate:\s*(\w+)} ) {
                $status = $1;
            }
            last;
        }

        print "\n" if $c;    # clear the last "." from above

        if ( $status eq 'success' ) {
            INFO("MySQL $mysql_version restored");
        }
        else {
            FATAL("Failed to restore MySQL $mysql_version: upgrade $id status '$status'");
            FATAL("$out");
            die 'Failed to restore MySQL';
        }
    }
    else {
        die qq[Cannot find upgrade_id from start_background_mysql_upgrade:\n$out];
    }

    return;
}

sub cleanup_mysql_57_packages {
    my @repos = qw{
      Mysql-connectors-community
      Mysql-tools-community
      Mysql57-community
      Mysql-tools-preview
    };

    remove_rpms_from_repos(@repos);

    return;
}

sub cleanup_mysql_80_packages {

    my @repos = qw{
      Mysql-connectors-community
      Mysql-tools-community
      Mysql80-community
      Mysql-tools-preview
    };

    remove_rpms_from_repos(@repos);

    return;
}

sub cleanup_mysql_102_packages {

    remove_rpms_from_repos('MariaDB102');

    return;
}

sub cleanup_mysql_103_packages {

    remove_rpms_from_repos('MariaDB103');

    return;
}

sub cleanup_mysql_105_packages {

    remove_rpms_from_repos('MariaDB105');

    return;
}

sub cleanup_mysql_106_packages {

    remove_rpms_from_repos('MariaDB106');

    return;
}

sub post_leapp_update_restore {

    INFO('Removing leapp from excludes in /etc/yum.conf');
    my $txt = eval { File::Slurper::read_text("/etc/yum.conf") };
    if ( length $txt ) {
        $txt =~ s/\s*python2-leapp,snactor,leapp-upgrade-el7toel8,leapp//ms;
        File::Slurper::write_text( "/etc/yum.conf", $txt );
    }

    # plugins can use MySQL - restore database earlier
    run_once('reinstall_mysql_packages');

    run_once(
        'restore_perl_xs' => sub {
            restore_perl_xs(DISTRO_PERL_XS_PATH);
            restore_perl_xs( $Config{'installsitearch'} );

            return;
        }
    );

    run_once(
        'restore_plugins' => sub {

            # Restore YUM arch plugins.
            my $stash            = read_stage_file();
            my $yum_arch_plugins = $stash->{'restore'}->{'yum'} // [];
            if (@$yum_arch_plugins) {
                INFO('Restoring cPanel yum-based-plugins');
                ssystem( qw{ /usr/bin/dnf -y reinstall }, @$yum_arch_plugins );
            }

            return;
        }
    );

    run_once('check_pecl_packages');
    run_once('reinstall_imunify_360');
    run_once('reinstall_wordpress_toolkit');
    run_once('reinstall_influxdb');
    run_once('reinstall_jetbackup');
    run_once('kernel_check');
    run_once('restore_kernel_care');
    run_once('restore_imunify_features');
    run_once('restore_nixstats');
    run_once('post_install_check_litespeed');
    run_once('reinstall_digital_ocean_droplet_agent');

    return;
}

sub kernel_check {
    my @kernel_rpms = `/usr/bin/rpm -qa`;
    @kernel_rpms = sort grep { m/^kernel-\S+el7/ } @kernel_rpms;
    return unless @kernel_rpms;
    chomp @kernel_rpms;

    my $msg = "The following kernels should probably be removed as they will not function on AlmaLinux 8:\n\n";
    foreach my $kernel (@kernel_rpms) {
        $msg .= "    $kernel\n";
    }

    $msg .= "\nYou can remove these by running: /usr/bin/rm -e " . join( " ", @kernel_rpms ) . "\n";

    recommend_postinstall($msg);

    return;
}

sub recommend_postinstall($msg) {
    my $recommendations = read_stage_file()->{'a_postinstall_recommendation'} // [];
    push @$recommendations, $msg;
    update_stage_file( { 'a_postinstall_recommendation' => $recommendations } );

    return;
}

sub backup_pecl_packages {
    my @ea_versions = qw{ea-php70 ea-php71 ea-php72 ea-php73 ea-php74 ea-php80};

    foreach my $v (@ea_versions) {
        _store_pecl_for( qq[/opt/cpanel/$v/root/usr/bin/pecl], $v );
    }

    _store_pecl_for( q[/usr/local/cpanel/3rdparty/bin/pecl], 'cpanel' );

    return;
}

sub check_pecl_packages {

    my $stash = read_stage_file();

    return unless ref $stash->{pecl} && scalar keys $stash->{pecl}->%*;

    foreach my $v ( sort keys $stash->{pecl}->%* ) {
        my $previously_installed = $stash->{pecl}->{$v};

        return unless ref $previously_installed && scalar keys $previously_installed->%*;

        my $bin;
        if ( $v eq 'cpanel' ) {
            $bin = q[/usr/local/cpanel/3rdparty/bin/pecl];
        }
        else {
            $bin = qq[/opt/cpanel/$v/root/usr/bin/pecl];
        }

        my $currently_installed = _get_pecl_installed_for($bin) // {};

        my $displayed_header = 0;
        foreach my $pkg ( sort keys $previously_installed->%* ) {
            next if $currently_installed->{$pkg};

            # for now do not check the version

            if ( !$displayed_header ) {
                $displayed_header = 1;
                WARN( q[*] x 20 );
                WARN("WARNING: Missing pecl package(s) for $bin");
                WARN("Please reinstall these packages");
                WARN( q[*] x 20 );
            }

            WARN("- $pkg");
        }

        WARN('#') if $displayed_header;
    }

    return;
}

sub _store_pecl_for ( $bin, $name ) {
    my $list = _get_pecl_installed_for($bin);

    return unless ref $list && scalar keys $list->%*;

    update_stage_file( { pecl => { $name => $list } } );

    return;
}

sub _get_pecl_installed_for( $bin ) {

    return unless -x $bin;

    my $out = Cpanel::SafeRun::Simple::saferunnoerror( $bin, 'list' ) // '';
    return if $?;

    my @lines = split( /\n/, $out );
    return unless scalar @lines >= 4;

    shift @lines for 1 .. 3;    # remove the header

    my $installed;

    foreach my $l (@lines) {
        my ( $package, $v, $state ) = split( /\s+/, $l, 3 );
        $installed->{$package} = $v;
    }

    return $installed;
}

sub clear_cpanel_caches {

    my @dirs = (

        # note: all cpanel users also have a '.cpanel/datastore'
        #       probably not necessary to cleanup
        '/root/.cpanel/datastore',    # cleanup root CachedCommand
    );

    my @files = qw{
      /var/cpanel/GetOS.cache
    };

    foreach my $d (@dirs) {
        ssystem( qw{/usr/bin/rm -rf}, $d );
    }

    unlink $_ foreach @files;

    return;
}

sub _fetch_imunify_installer ($product) {

    $product =~ s/Plus/+/;
    my %installer_scripts = (
        'imunifyAV'  => 'https://repo.imunify360.cloudlinux.com/defence360/imav-deploy.sh',
        'imunifyAV+' => 'https://repo.imunify360.cloudlinux.com/defence360/imav-deploy.sh',
        'imunify360' => 'https://www.repo.imunify360.cloudlinux.com/defence360/i360deploy.sh',
    );

    my $installer_url = $installer_scripts{$product} or do {
        ERROR("Unknown product type $product");
        return;
    };

    return _fetch_a_script( $installer_url, 'imunify_installer' );
}

sub _fetch_a_script ( $url, $template ) {
    my $response = eval {
        my $http = Cpanel::HTTP::Client->new()->die_on_http_error();
        $http->get($url);
    };

    if ( my $exception = $@ ) {
        ERROR("The system could not fetch the uninstall script for $template: $exception");
        return;
    }

    my $fh = File::Temp->new( TEMPLATE => "${template}_XXXX", SUFFIX => '.sh', UNLINK => 0, PERMS => 0600, TMPDIR => 1 );
    print {$fh} $response->{'content'};
    close $fh;

    return "$fh";
}

my $yum_list_cache;

sub yum_list ($invalidate_cache = 0) {
    return $yum_list_cache if !$invalidate_cache && $yum_list_cache;

    my @lines = split "\n", Cpanel::SafeRun::Errors::saferunnoerror(qw{/usr/bin/yum list installed});
    while ( my $line = shift @lines ) {
        last if $line && $line =~ m/^Installed Packages/;
    }
    shift @lines;

    my %repos;
    while ( my $line = shift @lines ) {
        chomp $line;
        my ( $package, $version, $repo ) = split( qr{\s+}, $line );

        if ( !length $version ) {
            my $extra_line = shift @lines;
            chomp $extra_line;
            $extra_line =~ s/^\s+//;
            ( $version, $repo ) = split( ' ', $extra_line );
        }
        if ( !length $repo ) {
            $repo = shift @lines;
            chomp $repo;
            $repo =~ s/\s+//g;
        }
        length $repo or next;    # We screwed up the parse. move on.

        $repo =~ s/^\@// or next;
        $repos{$repo} ||= [];
        next if $repo eq 'installed';    # Not installed from a repo.

        $package =~ s/\.(noarch|x86_64)$//;
        my $arch = $1 // '?';
        push $repos{$repo}->@*, { 'package' => $package, 'version' => $version, arch => $arch };
    }

    return $yum_list_cache = \%repos;
}

sub get_installed_rpms_in_repo (@repo_list) {

    my @to_remove;
    my $installed = yum_list();

    # Regex for repos.
    if ( ref $repo_list[0] eq 'Regexp' ) {
        scalar @repo_list == 1 or Carp::confess("too many args");
        my $regex = shift @repo_list;

        @repo_list = grep { $_ =~ $regex } keys %$installed;
    }

    foreach my $repo (@repo_list) {
        next unless ref $installed->{$repo};
        next unless scalar $installed->{$repo}->@*;
        push @to_remove, map { $_->{'package'} } $installed->{$repo}->@*;
    }

    return @to_remove;
}

sub remove_rpms_from_repos (@repo_list) {
    my @to_remove = get_installed_rpms_in_repo(@repo_list);

    return unless @to_remove;

    INFO( "Removing packages for " . join( ", ", @repo_list ) );

    ssystem( qw{/usr/bin/yum -y erase}, @to_remove );

    return;
}

sub backup_3rdparty_file ($file) {
    my $target = "$file.elevate_backup";
    return File::Copy::copy( $file, $target );
}

sub remove_jetbackup {
    return unless Cpanel::Pkgr::is_installed('jetbackup5-cpanel');

    my $repos = yum_list();
    my $jetbackup_tier =
        $repos->{'jetapps-stable'} ? 'jetapps-stable'
      : $repos->{'jetapps-edge'}   ? 'jetapps-edge'
      : $repos->{'jetapps-beta'}   ? 'jetapps-beta'
      :                              'jetapps-stable';    # Just give up and choose stable if you can't guess.
    INFO("Jetbackup tier '$jetbackup_tier' detected. Not removing jetbackup. Will re-install it after elevate.");
    my @reinstall = get_installed_rpms_in_repo(qw/jetapps jetapps-stable jetapps-beta jetapps-edge/);
    unshift @reinstall, $jetbackup_tier;

    my $data = {
        tier     => $jetbackup_tier,
        packages => \@reinstall,
    };

    update_stage_file( { 'reinstall' => { 'jetbackup' => $data } } );

    return;
}

sub reinstall_jetbackup {
    my $data = read_stage_file()->{'reinstall'}->{'jetbackup'};
    return unless ref $data && ref $data->{packages};

    INFO("Re-installing jetbackup.");

    my $tier     = $data->{tier};
    my @packages = $data->{packages}->@*;
    ssystem( qw{/usr/bin/yum -y reinstall  --disablerepo=* --enablerepo=jetapps}, "--enablerepo=$tier", @packages );

    return;
}

sub remove_influxdb {
    return unless Cpanel::Pkgr::is_installed('telegraf');
    INFO("Not removing influxdb. Will re-install it after elevate.");
    update_stage_file( { 'reinstall' => { 'influxdb' => 1 } } );

    return;
}

sub reinstall_influxdb {
    return unless read_stage_file()->{'reinstall'}->{'influxdb'};
    INFO("Re-installing telegraf for influxdb");
    ssystem_and_die(qw{/usr/bin/yum -y reinstall telegraf});

    return;
}

sub has_nixstats {
    return -e q[/etc/systemd/system/nixstatsagent.service] || -e q[/usr/local/bin/nixstatsagent];
}

sub remove_nixstats {

    return unless has_nixstats();

    INFO("Removing nixstats");

    my $backup_dir = ELEVATE_BACKUP_DIR . "/nixstats";

    File::Path::make_path($backup_dir);
    die "Fail to create backup directory: $backup_dir" unless -d $backup_dir;

    my @to_backup = qw{ /etc/nixstats-token.ini /etc/nixstats.ini };

    # files we need to restore later
    my $to_restore = {};

    foreach my $f (@to_backup) {
        next unless -f $f;
        my $name   = File::Basename::basename($f);
        my $backup = "$backup_dir/$name";
        File::Copy::move( $f, $backup );

        $to_restore->{$backup} = $f;
    }

    my $service = q[nixstatsagent];

    my $is_enabled = _is_service_enabled($service);

    ssystem( qw{/usr/bin/systemctl disable}, $service ) if $is_enabled;
    ssystem( qw{/usr/bin/systemctl stop},    $service );

    my $pip;

    if ( -x q[/usr/bin/pip3] ) {
        $pip = q[/usr/bin/pip3];
    }
    elsif ( -x q[/usr/bin/pip] ) {
        $pip = q[/usr/bin/pip];
    }

    if ($pip) {
        ssystem( $pip, qw{uninstall -y nixstatsagent} );
    }
    else {
        ERROR("Cannot remove nixstatsagent: cannot find pip binary");
    }

    my $data = {
        service_enabled => $is_enabled,
        to_restore      => $to_restore,
    };

    update_stage_file( { 'reinstall' => { 'nixstats' => $data } } );

    return;
}

sub restore_nixstats {
    my $data = read_stage_file()->{'reinstall'}->{'nixstats'};
    return unless ref $data;

    INFO("Restoring nixstats");

    # we reinstall nixstats using a non existing user id
    #   this avoid adding some polution to their account
    #   by creating a server we are then going to replace just after
    # alternatively we could use the user from the nixstats-token.ini file
    my $user = q[deadbeefdeadbeefdeadbeef];

    my $installer_script = _fetch_a_script( 'https://www.nixstats.com/nixstatsagent.sh', 'nixstatsagent' );

    ssystem( '/usr/bin/bash', $installer_script, $user );

    unlink $installer_script;

    if ( !-x q[/usr/local/bin/nixstatsagent] ) {
        ERROR("Missing nixstatsagent binary: /usr/local/bin/nixstatsagent");
    }

    my $service = q[nixstatsagent];

    # Stopping the agent
    ssystem( qw{/usr/bin/systemctl stop}, $service );

    # Restoring backup files
    my $to_restore = $data->{to_restore};

    foreach my $src ( sort keys %$to_restore ) {
        my $destination = $to_restore->{$src};

        File::Copy::copy( $src, $destination );
    }

    # restoring the state of the service before elevation
    if ( $data->{service_enabled} ) {
        ssystem( qw{/usr/bin/systemctl enable}, $service );
    }
    else {    # leave it disabled
        ssystem( qw{/usr/bin/systemctl disable}, $service );
    }

    # do not really need to start/stop the daemon, we are about to reboot
    #   but start it for sanity purpose

    ssystem( qw{/usr/bin/systemctl start}, $service );
    if ( $? == 0 ) {
        INFO("nixstatsagent restored");
    }
    else {
        WARN("Failed to start nixstatsagent.service");
    }

    return;
}

sub remove_wordpress_toolkit {
    return unless Cpanel::Pkgr::is_installed('wp-toolkit-cpanel');

    INFO("Removing Wordpress Toolkit");

    INFO("Removing the rpm wp-toolkit-cpanel (--noscripts)");
    backup_3rdparty_file('/usr/local/cpanel/3rdparty/wp-toolkit/var/wp-toolkit.sqlite3');
    backup_3rdparty_file('/usr/local/cpanel/3rdparty/wp-toolkit/var/etc/.shadow');
    my ($output) = Cpanel::SafeRun::Errors::saferunallerrors(qw{/usr/bin/rpm -e --noscripts wp-toolkit-cpanel});
    DEBUG($output) if $output;

    yum_list(1);    # Invalidate the cache since we just ran an rpm -e by hand.
    remove_rpms_from_repos(qw/wp-toolkit-cpanel wp-toolkit-thirdparties/);

    update_stage_file( { 'reinstall' => { 'wordpress_toolkit' => 1 } } );

    return;
}

sub reinstall_wordpress_toolkit {
    return unless read_stage_file()->{'reinstall'}->{'wordpress_toolkit'};

    INFO("Restoring Wordpress Toolkit");
    my $installer_script = _fetch_a_script( 'https://wp-toolkit.plesk.com/cPanel/installer.sh', 'wptk_installer' );

    ssystem( '/usr/bin/bash', $installer_script );
    unlink $installer_script;

    return;
}

sub pre_install_check_litespeed {

    my $ls_cfg_dir = q[/usr/local/lsws/conf];
    return unless -d $ls_cfg_dir;

    INFO("LiteSpeed is installed");

    # check if the license is valid before updating
    ssystem(qw{/usr/local/lsws/bin/lshttpd -V});
    my $has_valid_license = $? == 0 ? 1 : 0;

    my $data = {
        has_valid_license => $has_valid_license,
    };

    update_stage_file( { 'reinstall' => { 'litespeed' => $data } } );

    return;
}

sub post_install_check_litespeed {
    my $data = read_stage_file()->{'reinstall'}->{'litespeed'};
    return unless ref $data;

    INFO("Checking LiteSpeed");

    # check the current license
    if ( $data->{has_valid_license} ) {
        ssystem(qw{/usr/local/lsws/bin/lshttpd -V});
        ERROR("LiteSpeed license is not valid. Check /usr/local/lsws/conf/serial.no") if $? != 0;
    }

    ssystem(qw{/usr/bin/systemctl restart lsws});

    return;
}

sub reinstall_digital_ocean_droplet_agent {
    return unless Cpanel::Pkgr::is_installed('droplet-agent');
    return unless -f '/etc/yum.repos.d/droplet-agent.repo';

    ssystem(qw{/usr/bin/yum -y reinstall droplet-agent});
}

sub remove_imunify_360 {

    # One of these 2 rpms should be in place or imunify isn't really functioning.
    my $im360 = Cpanel::Pkgr::is_installed('imunify360-firewall');
    my $imav  = Cpanel::Pkgr::is_installed('imunify-antivirus');
    return unless $im360 || $imav;

    my $agent_bin = IMUNIFY_AGENT;
    return unless -x $agent_bin;
    my $license_data = eval { Cpanel::JSON::Load(`$agent_bin version --json 2>&1`) } // {};
    return unless $license_data->{'license'}->{'status'};    # Must be true.

    my $product_type = $license_data->{'license'}->{'license_type'};

    INFO("Removing $product_type prior to upgrade.");

    update_stage_file( { 'reinstall' => { 'imunify' => $product_type } } );
    INFO("Product $product_type detected. Uninstalling before upgrade for later restore");

    my $installer_script = _fetch_imunify_installer($product_type) or return;

    ssystem( '/usr/bin/bash', $installer_script, '--uninstall' );
    unlink $installer_script;

    # Cleanup any lingering packages.
    remove_rpms_from_repos('imunify');

    return;
}

sub reinstall_imunify_360 {
    my $product_type = read_stage_file()->{'reinstall'}->{'imunify'} || return;

    my $installer_script = _fetch_imunify_installer($product_type) or return;

    ssystem( '/usr/bin/bash', $installer_script );
    unlink $installer_script;

    return;
}

sub post_upgrade_check {

    unless ( Cpanel::OS::major() == 8 && Cpanel::OS::distro() eq 'almalinux' ) {
        FATAL('Your distro does not looks like Almalinux 8.');
        return 1;
    }

    # call a cpanel binary
    ssystem_and_die(qw{/usr/local/cpanel/cpanel -V});

    return 0;
}

sub purge_perl_xs($path) {

    return unless length $path && -d $path;

    my @perl_modules;

    File::Find::find(
        sub {
            return unless substr( $_, -3 ) eq '.pm';
            return if -l $_;
            return unless -f $_;

            push @perl_modules, $File::Find::name;

        },
        $path
    );

    my $path_len = length($path);
    @perl_modules = map { substr( $_, $path_len + 1 ) } sort { $a cmp $b } @perl_modules;

    my $xspm_to_rpm = xspm_to_rpm();

    my %rpms_to_restore;
    my @modules_to_restore;
    foreach my $file (@perl_modules) {

        # We can only convert distro perl arch perl modules to RPM.
        if ( $path eq DISTRO_PERL_XS_PATH && length $xspm_to_rpm->{$file} ) {
            $rpms_to_restore{$file} = $xspm_to_rpm->{$file};
        }
        else {
            push @modules_to_restore, $file;
        }
    }

    my $stash = {};
    if (%rpms_to_restore) {
        INFO('The following `cpan` installed perl Modules will be removed and replaced with a AlmaLinux 8 RPM after upgrade:');
        foreach my $file ( sort { $rpms_to_restore{$a} cmp $rpms_to_restore{$b} || $a cmp $b } keys %rpms_to_restore ) {
            INFO( sprintf( "  %20s => %s", $file, $rpms_to_restore{$file} ) );

            my $files_in_rpm = $stash->{'restore'}->{$path}->{'rpm'}->{ $rpms_to_restore{$file} } //= [];
            unless ( grep { $_ eq $file } @$files_in_rpm ) {    # Only if we've not stored this.
                push @$files_in_rpm, $file;
                unlink "$path/$file";
            }
        }
        INFO(' ');
    }

    if (@modules_to_restore) {
        WARN("The following modules will likely not be functional on AlmaLinux 8 and will be disabled. You will need to restore these manually:");
        my $to_restore = $stash->{'restore'}->{$path}->{'cpan'} //= [];
        foreach my $file (@modules_to_restore) {
            WARN("    $path/$file");
            next if grep { $_ eq $file } @$to_restore;    # We've already stashed this.
            push @$to_restore, $file;
            rename "$path/$file", "$path/$file.o";
        }
    }

    update_stage_file($stash);

    return;
}

sub restore_perl_xs ($path) {
    my $stash = read_stage_file();

    if ( $path eq DISTRO_PERL_XS_PATH ) {
        my $rpms = $stash->{'restore'}->{ DISTRO_PERL_XS_PATH() }->{'rpm'};

        my @cmd = ( '/usr/bin/dnf', '-y', '--enablerepo=epel', '--enablerepo=powertools', 'install', sort keys %$rpms );
        ssystem(@cmd);
    }

    my $cpan_modules = $stash->{$path}->{'cpan'} // return;

    # TODO: Let's restore this with /usr/bin/cpan!
    my $msg = "The following XS modules will need to be re-installed:\n\n";
    foreach my $module (@$cpan_modules) {
        $msg .= "   $module\n";
    }
    recommend_postinstall($msg);

    return;
}

sub xspm_to_rpm () {
    return {
        'IO/Pty.pm'           => 'perl-IO-Tty',
        'IO/Tty.pm'           => 'perl-IO-Tty',
        'IO/Tty/Constant.pm'  => 'perl-IO-Tty',
        'JSON/Syck.pm'        => 'perl-YAML-Syck',
        'JSON/XS.pm'          => 'perl-JSON-XS',
        'JSON/XS/Boolean.pm'  => 'perl-JSON-XS',
        'YAML/Dumper/Syck.pm' => 'perl-YAML-Syck',
        'YAML/Loader/Syck.pm' => 'perl-YAML-Syck',
        'YAML/Syck.pm'        => 'perl-YAML-Syck',
        'common/sense.pm'     => 'perl-common-sense',
        'version.pm'          => 'perl-version',
        'version/regex.pm'    => 'perl-version',
        'version/vpp.pm'      => 'perl-version',
        'version/vxs.pm'      => 'perl-version',
    };
}

use constant _CHECK_YUM_REPO_BITMASK_UNVETTED                    => 1;
use constant _CHECK_YUM_REPO_BITMASK_INVALID_SYNTAX              => 2;
use constant _CHECK_YUM_REPO_BITMASK_USE_RPMS_FROM_UNVETTED_REPO => 4;
use constant _CHECK_YUM_REPO_BITMASK_HAS_UNUSED_REPO_ENABLED     => 8;

sub blockers_check ( $self, $all = 0 ) {

    die unless ref $self;

    unless ( $< == 0 ) {
        ERROR("This script can only be run by root");
        return 666;
    }

    $self->{blockers}                = [];
    $self->{_abort_on_first_blocker} = !$all;

    eval {
        $self->_blockers_check();
        1;
    };

    if ( my $error = $@ ) {
        if ( ref $error eq 'cpev::Blocker' ) {
            ERROR( $error->{msg} );
            return $error->{id} // 401;
        }
        WARN("Unkown error while checking blockers: $error");
        return 127;    # unknown error
    }

    return scalar $self->{blockers}->@*;
}

#
# by default abort on the first failure,
#   except in check mode where we want all failures
#
sub has_blocker ( $self, $id, $msg ) {

    # FIXME: consider removing the id
    my $blocker = bless { id => $id, msg => $msg }, 'cpev::Blocker';

    die $blocker if $self->{_abort_on_first_blocker};

    WARN( <<~"EOS");
    *** Elevation Blocker detected: ***
    $msg
    EOS
    WARN('.');

    $self->{blockers} //= [];
    push $self->{blockers}->@*, $blocker;

    return $blocker;
}

# separate sub, so that it can be silenced during tests:
sub _do_warn_skip_version_check {
    WARN("The --skip-cpanel-version-check option was specified! This option is provided for testing purposes only! cPanel may not be able to support the resulting conversion. Please consider whether this is what you want.");
    return;
}

sub _blocker_is_missing_cpanel_whm ($self) {
    if ( !-x q[/usr/local/cpanel/cpanel] ) {
        $self->has_blocker( 1, 'This script is only designed to work with cPanel & WHM installs. cPanel & WHM do not appear to be present on your system.' );
    }

    return 0;
}

sub _blocker_is_invalid_cpanel_whm ($self) {
    if ( !$Cpanel::Version::Tiny::major_version ) {
        $self->has_blocker( 1, 'Invalid cPanel & WHM major_version' );
    }

    return 0;
}

sub _blocker_is_old_cpanel ($self) {
    if ( $Cpanel::Version::Tiny::major_version <= 100 ) {
        $self->has_blocker( 2, "This version $Cpanel::Version::Tiny::VERSION_BUILD does not support upgrades to AlmaLinux 8. Please upgrade to cPanel version 102 or better." );
    }

    return 0;
}

sub _blocker_cpanel_needs_update ($self) {
    if ( !$self->getopt('skip-cpanel-version-check') ) {
        my $tiers_obj = Cpanel::Update::Tiers->new( logger => $logger );
        if ( !grep { Cpanel::Version::Compare::compare( $Cpanel::Version::Tiny::VERSION_BUILD, '==', $_ ) } $tiers_obj->get_flattened_hash()->@{qw/edge current release stable lts/} ) {
            $self->has_blocker( 2, "This installation of cPanel ($Cpanel::Version::Tiny::VERSION_BUILD) does not appear to be up to date. Please upgrade cPanel to a most recent version." );
        }
    }
    else {
        _do_warn_skip_version_check();
    }

    return 0;
}

sub _blocker_is_non_centos7 ($self) {
    unless ( Cpanel::OS::major() == 7 && Cpanel::OS::distro() eq 'centos' ) {
        $self->has_blocker( 3, 'This script is only designed to upgrade CentOS 7 to AlmaLinux 8' );
    }

    return 0;
}

sub _blocker_is_old_centos7 ($self) {
    if ( Cpanel::OS::minor() < 9 ) {
        $self->has_blocker( 4, 'You need to run CentOS 7.9 and later to upgrade AlmaLinux 8. You are currently using ' . Cpanel::OS::display_name() );
    }

    return 0;
}

sub _blocker_is_experimental_os ($self) {
    if ( -e '/var/cpanel/caches/Cpanel-OS.custom' ) {
        $self->has_blocker( 5, 'Experimental OS detected. This script only supports CentOS 7 upgrades' );
    }

    return 0;
}

sub _blocker_is_sandbox ($self) {
    if ( -e q[/var/cpanel/dev_sandbox] ) {
        $self->has_blocker( 6, 'Cannot elevate a sandbox...' );
    }

    return 0;
}

sub _blocker_is_calendar_installed ($self) {
    if ( Cpanel::Pkgr::is_installed('cpanel-ccs-calendarserver') ) {
        $self->has_blocker( 7, <<~'EOS');
        You have the cPanel Calendar Server installed. Upgrades with this server in place are not supported.
        Removal of this server can lead to data loss.
        EOS
    }

    return 0;
}

sub _blocker_is_postgresql_installed ($self) {
    if ( Cpanel::Pkgr::is_installed('postgresql-server') ) {
        my $pg_full_ver = Cpanel::Pkgr::get_package_version('postgresql-server');
        my ($old_version) = $pg_full_ver =~ m/^(\d+\.\d+)/a;

        my $msg = qq[You have postgresql-server version $old_version installed.\n];
        if ( $old_version < 10 ) {
            $msg .= qq[This is upgraded irreversably to version 10.0 when you switch to almalinux 8\n];
        }
        $msg .= qq[We recommend data backup and removal of all postgresql packages before upgrade to AlmaLinux 8.\n];
        if ( $old_version < 10 ) {
            $msg .= qq[To re-install postgresql 9 on AlmaLinux 8, you can run: `dnf -y module enable postgresql:9.6; dnf -y install postgresql-server`\n];
        }

        $self->has_blocker( 8, $msg );
    }

    return 0;
}

sub _blocker_non_bind_powerdns ( $self, $nameserver ) {
    if ( $nameserver eq 'nsd' or $nameserver eq 'mydns' ) {
        $self->has_blocker( 9, <<~'EOS');
        AlmaLinux 8 only supports bind or powerdns. We suggest you switch to powerdns.
        Before upgrading, we suggest you run: /scripts/setupnameserver powerdns.
        EOS
    }

    return 0;
}

sub _blocker_wrong_location ($self) {

    # ensure the script is install at the correct location
    my $running_from = Cwd::abs_path($0) // '';
    if (   $running_from ne '/scripts/elevate-cpanel'
        && $running_from ne '/usr/local/cpanel/scripts/elevate-cpanel' ) {
        $self->has_blocker( 10, <<~'EOS');
        The script is not installed to the correct directory.
        Please install it to /scripts/elevate-cpanel and run it again.
        EOS
    }

    return 0;
}

sub _blocker_old_mysql ( $self, $mysql_version = '' ) {

    # checking MySQL version
    if ( $mysql_version eq '5.7' ) {
        $self->has_blocker( 11, <<~'EOS');
        You are using MySQL 5.7 community server.
        This version is not available for AlmaLinux 8.
        You first need to update your MySQL server to 8.0 or later.

        You can update to version 8.0 using the following command:

            /usr/local/cpanel/bin/whmapi1 start_background_mysql_upgrade version=8.0

        Once the MySQL upgrade is finished, you can then retry to elevate to AlmaLinux 8.
        EOS
    }
    elsif ( $mysql_version eq '10.2' ) {
        $self->has_blocker( 12, <<~'EOS');
        You are using MariaDB server 10.2, this version is not available for AlmaLinux 8.
        You first need to update MariaDB server to 10.3 or later.

        You can update to version 10.3 using the following command:

            /usr/local/cpanel/bin/whmapi1 start_background_mysql_upgrade version=10.3

        Once the MariaDB upgrade is finished, you can then retry to elevate to AlmaLinux 8.
        EOS
    }
    else {
        my %supported_mysql_versions = (
            map { $_ => 1 }
              qw{
              8.0
              10.3
              10.4
              10.5
              10.6
              }
        );

        if ( !$supported_mysql_versions{$mysql_version} ) {
            $self->has_blocker( 13, <<~"EOS");
            We do not know how to upgrade to AlmaLinux 8 with MySQL version $mysql_version.
            Please open a support ticket.
            EOS
        }

        # store the MySQL version we started from
        update_stage_file( { 'mysql-version' => $mysql_version } );
    }

    return 0;
}

sub _blocker_invalid_yum_repos ($self) {
    if ( my $status = $self->_check_yum_repos() ) {
        my $msg = '';
        if ( $status & _CHECK_YUM_REPO_BITMASK_INVALID_SYNTAX ) {
            $msg .= <<~'EOS';
            One or more enabled YUM repo are using invalid syntax.
            '\$' variables behave differently in repo files between RedHat 7 and RedHat 8.
            RedHat 7 interpolates '\$' variable whereas RedHat 8 does not.

            Please fix the files before continuing the update.
            EOS
        }
        if ( $status & _CHECK_YUM_REPO_BITMASK_UNVETTED ) {
            $msg .= <<~'EOS';
            One or more enabled YUM repo are currently unsupported.
            You should disable these repositories and remove packages installed from them
            before continuing the update.

            Consider reporting this limitation to https://github.com/cpanel/elevate/issues
            EOS
        }

        if ( $self->{_abort_on_first_blocker} ) {    # autofix when --check is not used
            $self->_autofix_yum_repos();

            # perform a second check to make sure we are in good shape
            $status = $self->_check_yum_repos();
        }

        $self->has_blocker( 14, $msg ) if $status;
    }

    return 0;
}

sub _blocker_unstable_yum ($self) {
    $self->has_blocker( 15, q[yum is not stable] ) unless _yum_is_stable();

    return 0;
}

sub _blocker_invalid_ssh_config ($self) {
    $self->has_blocker( 16, q[Issue with sshd configuration] ) unless _sshd_setup();

    return 0;
}

sub _blocker_old_jetbackup ($self) {
    $self->has_blocker( 17, q[AlmaLinux 8 does not support JetBackup prior to version 5. Please upgrade JetBackup before elevate.] ) if _use_jetbackup4_or_earlier();

    return 0;
}

sub _blocker_mysql_upgrade_in_progress ($self) {
    if ( -e q[/var/cpanel/mysql_upgrade_in_progress] ) {
        $self->has_blocker( 18, q[MySQL upgrade in progress. Please wait for the MySQL upgrade to finish.] );
    }

    return 0;
}

sub _blocker_disk_space ($self) {
    $self->has_blocker( 99, q[disk space issue] ) unless _disk_space_check();

    return 0;
}

sub _blocker_system_update ($self) {
    $self->has_blocker( 101, q[System is not up to date] ) unless _system_update_check();

    return 0;
}

sub _blocker_bad_nics_naming ($self) {
    $self->has_blocker( 102, q[Missing ] . SBIN_IP . ' binary' ) unless -x SBIN_IP;
    my @eths = _get_nics();
    if ( @eths >= 2 ) {
        $self->has_blocker( 103, <<~'EOS');
        Your machine has multiple network interface cards (NICs) using kernel-names (ethX).
        Since the upgrade process cannot guarantee their stability after upgrade, you cannot upgrade.

        Please provide those interfaces new names before continuing the update.
        EOS
    }

    return 0;
}

sub _blockers_check ($self) {

    my $cpconf = Cpanel::Config::LoadCpConf::loadcpconf();

    $self->_blocker_is_missing_cpanel_whm();
    $self->_blocker_is_invalid_cpanel_whm();
    $self->_blocker_is_old_cpanel();
    $self->_blocker_cpanel_needs_update();
    $self->_blocker_is_non_centos7();
    $self->_blocker_is_old_centos7();
    $self->_blocker_is_experimental_os();
    $self->_blocker_is_sandbox();
    $self->_blocker_is_calendar_installed();
    $self->_blocker_is_postgresql_installed();
    $self->_blocker_non_bind_powerdns( $cpconf->{'local_nameserver_type'} );
    $self->_blocker_wrong_location();
    $self->_blocker_old_mysql( $cpconf->{'mysql-version'} );
    $self->_blocker_invalid_yum_repos();
    $self->_blocker_unstable_yum();
    $self->_blocker_invalid_ssh_config();
    $self->_blocker_old_jetbackup();
    $self->_blocker_mysql_upgrade_in_progress();
    $self->_blocker_disk_space();
    $self->_blocker_system_update();
    $self->_blocker_bad_nics_naming();

    return 0;
}

sub _system_update_check() {

    INFO("Checking if your system is up to date: ");
    ssystem(qw{/usr/bin/yum clean all});
    if ( ssystem(qw{/usr/bin/yum check-update}) != 0 ) {
        WARN("Your system is not up to date please run: /usr/bin/yum update");
        return;
    }

    INFO("Checking /scripts/sysup");
    if ( ssystem("/scripts/sysup") != 0 ) {
        WARN("/scripts/sysup failed, please fix it and rerun it before upgrading.");
        return;
    }

    return 1;
}

sub _use_jetbackup4_or_earlier() {
    return unless Cpanel::Pkgr::is_installed('jetbackup');
    my $v = Cpanel::Pkgr::get_package_version("jetbackup");

    if ( defined $v && $v =~ qr{^[1-4]\b} ) {
        WARN("JetBackup version $v currently installed.");
        return 1;
    }

    return;
}

sub _autofix_yum_repos($self) {

    if ( ref $self->{_yum_repos_path_using_invalid_syntax} ) {
        my @files_with_invalid_syntax = $self->{_yum_repos_path_using_invalid_syntax}->@*;

        foreach my $f (@files_with_invalid_syntax) {
            INFO( q[Fixing \$ variables in repo file: ] . $f );
            Cpanel::SafeRun::Simple::saferunnoerror( $^X, '-pi', '-e', 's{\\\\\$}{\$}g', $f );
        }
    }

    if ( ref $self->{_yum_repos_to_disable} ) {
        my @repos_to_disable = $self->{_yum_repos_to_disable}->@*;
        foreach my $repo (@repos_to_disable) {
            INFO(qq[Disabling unused yum repository: $repo]);
            Cpanel::SafeRun::Simple::saferunnoerror( qw{/usr/bin/yum-config-manager --disable}, $repo );
        }
    }

    return;
}

# $mask = $self->_check_yum_repos()
#   check current repos:
#       _CHECK_YUM_REPO_BITMASK_UNVETTED is set when using packages from unvetted repo
#       _CHECK_YUM_REPO_BITMASK_INVALID_SYNTAX is set when one ore more repo use invalid syntax
#
sub _check_yum_repos($self) {

    # (re)set the array to store the offending repo
    $self->{_yum_repos_path_using_invalid_syntax} = [];
    $self->{_yum_repos_to_disable}                = [];

    my %vetted = map { $_ => 1 } VETTED_YUM_REPO;

    my $repo_dir = YUM_REPOS_D;

    my $status_mask = 0;

    opendir( my $dh, $repo_dir ) or return ERROR("Cannot read directory $repo_dir - $!");
    foreach my $f ( readdir($dh) ) {

        next unless $f =~ m{\.repo$};
        my $path = "${repo_dir}/$f";

        next unless -f $path;

        my $txt = eval { File::Slurper::read_text($path) };

        next unless length $txt;

        my @lines = split( qr/\n/, $txt );

        my $current_repo_name;
        my $current_repo_enabled          = 1;
        my $current_repo_use_valid_syntax = 1;

        my $check_last_known_repo = sub {
            return unless length $current_repo_name;
            return unless $current_repo_enabled;

            if ( !$vetted{$f} ) {
                $status_mask |= _CHECK_YUM_REPO_BITMASK_UNVETTED;
                if ( my $total_pkg = scalar get_installed_rpms_in_repo($current_repo_name) ) {
                    ERROR(
                        sprintf(
                            "%d package(s) installed from unsupported YUM repo '%s' from %s",
                            $total_pkg,
                            $current_repo_name, $path
                        )
                    );
                    $status_mask |= _CHECK_YUM_REPO_BITMASK_USE_RPMS_FROM_UNVETTED_REPO;
                }
                else {
                    WARN( sprintf( "Unsupported YUM repo enabled '%s' without packages installed from %s", $current_repo_name, $path ) );

                    # no packages installed need to disable it
                    push( $self->{_yum_repos_to_disable}->@*, $current_repo_name );
                    $status_mask |= _CHECK_YUM_REPO_BITMASK_HAS_UNUSED_REPO_ENABLED;
                }
            }
            elsif ( !$current_repo_use_valid_syntax ) {
                WARN( sprintf( "YUM repo '%s' is using unsupported '\\\$' syntax in %s", $current_repo_name, $path ) );
                unless ( grep { $_ eq $path } $self->{_yum_repos_path_using_invalid_syntax}->@* ) {
                    push( $self->{_yum_repos_path_using_invalid_syntax}->@*, $path );
                }
                $status_mask |= _CHECK_YUM_REPO_BITMASK_INVALID_SYNTAX;
            }
            return;
        };

        foreach my $line (@lines) {
            next if $line =~ qr{^\s*\#};       # skip comments
            $line =~ s{\s*\#.+$}{};            # strip comments
            if ( $line =~ qr{^\s*\[\s*(.+)\s*\]} ) {
                $check_last_known_repo->();

                $current_repo_name             = $1;
                $current_repo_enabled          = 1;    # assume enabled unless explicitely disabled
                $current_repo_use_valid_syntax = 1;

                next;
            }
            next unless defined $current_repo_name;

            $current_repo_enabled = 0 if $line =~ m{^\s*enabled\s*=\s*0};

            # the \$ syntax does not behave the same between 7 and 8
            $current_repo_use_valid_syntax = 0 if $line =~ m{\\\$};
        }

        # check the last repo found
        $check_last_known_repo->();
    }

    return $status_mask;
}

sub _yum_is_stable () {
    my $errors = Cpanel::SafeRun::Errors::saferunonlyerrors(qw{/usr/bin/yum makecache});
    if ( $errors =~ m/\S/ms ) {
        ERROR('yum appears to be unstable. Please address this before upgrading');
        ERROR($errors);

        return 0;
    }

    if ( opendir( my $dfh, '/var/lib/yum' ) ) {
        my @transactions = grep { m/^transaction-all\./ } readdir $dfh;
        if (@transactions) {
            ERROR('There are unfinished yum transactions remaining. Please address these before upgrading. The tool `yum-complete-transaction` may help you with this task.');
            return 0;
        }
    }
    else {
        ERROR(qq{Could not read directory '/var/lib/yum': $!});
        return 0;
    }

    return 1;
}

sub _sshd_setup () {
    my $sshd_config = q[/etc/ssh/sshd_config];

    my $setup = eval { File::Slurper::read_binary($sshd_config) } // '';

    if ( $setup !~ m{^\s*PermitRootLogin\b}m ) {
        ERROR( <<~"EOS" );
        OpenSSH configuration file does not explicitly state the option PermitRootLogin in sshd_config file, which will default in RHEL8 to "prohibit-password".
        Please set the 'PermitRootLogin' value in $sshd_config before upgrading.
        EOS

        return 0;
    }

    return 1;
}

sub _disk_space_check() {

    # base unit size is in K
    my $K   = 1;
    my $MEG = 1_024 * $K;
    my $GIG = 1_024 * $MEG;

    # minimum disk space for some mount points
    # note we are not doing the sum per mount point
    #   - /boot is small enough
    #   - /usr/local/cpanel is not going to be used at the same time than /var/lib
    my $need_space = {
        '/boot'             => 120 * $MEG,
        '/usr/local/cpanel' => 1.5 * $GIG,    #
        '/var/lib'          => 3 * $GIG,
    };

    my @keys = ( sort keys %$need_space );

    my @df_cmd = ( qw{/usr/bin/df -k}, @keys );
    my $cmd    = join( ' ', @df_cmd );

    my $result = Cpanel::SafeRun::Simple::saferunnoerror(@df_cmd) // '';
    die qq[Fail checking disk space using: $cmd\n] if $?;

    my ( $header, @out ) = split( "\n", $result );

    if ( scalar @out != scalar @keys ) {
        my $count_keys = scalar @keys;
        my $count_out  = scalar @out;
        die qq[Fail: Cannot parse df output from: $cmd\n] . "# expected $count_keys lines ; got $count_out lines\n" . join( "\n", @out ) . "\n";
    }

    my @errors;

    my $ix = 0;
    foreach my $line (@out) {
        my $key = $keys[ $ix++ ];
        my ( undef, undef, undef, $available ) = split( /\s+/, $line );

        my $need = $need_space->{$key};

        next if $available > $need;

        my $str;
        if ( $need / $GIG > 1 ) {
            $str = sprintf( "- $key needs %2.2f G => available %2.2f G", $need / $GIG, $available / $GIG );
        }
        else {
            $str = sprintf( "- $key needs %d M => available %d M", $need / $MEG, $available / $MEG );
        }

        push @errors, $str;
    }

    # everything is fine: check ok
    return 1 unless @errors;

    my $details = join( "\n", @errors );

    my $error = <<"EOS";
** Warning **: your system does not have enough disk space available to update to AlmaLinux 8

$details
EOS

    warn $error . "\n";

    return 0;    # error
}

sub _get_nics {
    my $ip_info = Cpanel::SafeRun::Errors::saferunnoerror( SBIN_IP, 'addr' );

    my @eths;
    foreach my $line ( split /\n/xms, $ip_info ) {
        $line =~ /^[0-9]+: \s (eth[0-9]):/xms
          or next;

        my $eth   = $1;
        my $value = readlink "/sys/class/net/$eth"
          or next;

        $value =~ m{/virtual/}xms
          and next;

        push @eths, $eth;
    }

    return @eths;
}

sub setup_answer_file {
    my $leapp_dir = '/var/log/leapp';

    mkdir $leapp_dir unless -d $leapp_dir;

    my $leapp_answers = $leapp_dir . '/answerfile.userchoices';

    if ( -f $leapp_answers && -s _ ) {
        warn "Preserve leap answers file: ", $leapp_answers;
        return;
    }

    open( my $fh, '>', $leapp_answers ) or die qq[Fail to setup leapp anserfile.userchoices: $!];
    print {$fh} <<~'EOF';
        [remove_pam_pkcs11_module_check]
        confirm = True
        EOF
    close $fh;

    return;
}

sub install_cpanel_elevate_service {

    INFO( "Installing service " . SERVICE_NAME . " which will upgrade the server to AlmaLinux 8" );
    open( my $fh, '>', SERVICE_FILE ) or die;

    # Works only in systemd v240 and newer!
    # StandardOutput=append:/var/log/elevate-cpanel.log
    # StandardError=inherit

    my $log_file = LOG_FILE;

    print {$fh} <<~"EOF";
        [Unit]
        Description=Upgrade process from CentOS 7 to AlmaLinux 8.
        After=network.target network-online.target

        [Service]
        Type=simple
        # want to run it once per boot time
        RemainAfterExit=yes
        ExecStart=/usr/bin/bash -c 'exec /usr/local/cpanel/scripts/elevate-cpanel --service 2>&1 | /usr/bin/tee -a $log_file'

        [Install]
        WantedBy=multi-user.target
        EOF

    close $fh;

    ssystem_and_die( '/usr/bin/systemctl', 'daemon-reload' );
    ssystem_and_die( '/usr/bin/systemctl', 'enable', SERVICE_NAME );
    bump_stage();

    my $pid = fork();
    die qq[Failed to fork: $!] unless defined $pid;
    if ($pid) {
        INFO( 'Starting service ' . SERVICE_NAME );
        return 0;
    }
    else {
        unlink(PID_FILE);    # release the pid so the service can use it
        ssystem_and_die( '/usr/bin/systemctl', 'start', SERVICE_NAME );
        exit(0);
    }
}

# TODO: We're going to need to store reboot time so we know if the last reboot has happened when we re-run the script.

sub read_stage_file {
    return eval { Cpanel::JSON::LoadFile(ELEVATE_STAGE_FILE) } // {};
}

sub save_stage_file ($stash) {
    open( my $fh, '>', ELEVATE_STAGE_FILE ) or LOGDIE( "Fail to open " . ELEVATE_STAGE_FILE . ": $!" );
    print {$fh} Cpanel::JSON::pretty_canonical_dump($stash);
    close $fh;

    return 1;
}

sub update_stage_file( $data ) {

    die q[Need a hash] unless ref $data eq 'HASH';

    my $current = read_stage_file();
    my $merged  = Hash::Merge::merge( $data, $current );

    return save_stage_file($merged);
}

sub get_stage {
    my $stage_info = read_stage_file();
    return $stage_info->{'stage_number'} // 0;
}

sub bump_stage ($by = 1) {

    my $stage_id = get_stage() + $by;

    update_stage_file( { stage_number => $stage_id } );

    return $stage_id;
}

sub reboot {
    bump_stage();

    # protection
    my $stage = get_stage();

    if ( $stage > VALID_STAGES + 1 ) {
        LOGDIE(qq[Cannot reboot reaching stage $stage]);
    }
    elsif ( $stage <= VALID_STAGES ) {
        print_box( "Rebooting into stage $stage of " . VALID_STAGES );
    }
    else {
        print_box("Doing final reboot");
    }

    if ( request_manual_reboots() ) {
        WARN("Manual Reboot Mode Enabled: please reboot the server to move to the next stage $stage");
        return 0;
    }

    my $exit = ssystem( '/usr/sbin/reboot', 'now' ) or return 0;
    LOGDIE("Failed to reboot system please correct this and reboot");
}

sub request_manual_reboots() {
    my $content = read_stage_file();
    return !!$content->{manual_reboots};
}

sub read_redhat_release() {
    my ($first_line) = split( "\n", Cpanel::LoadFile::loadfile('/etc/redhat-release') // '' );

    return $first_line;
}

sub ssystem (@args) {
    INFO( "Running: " . join( " ", @args ) );
    print "\n";    # Buffer so they can more easily read the output.
    my $ret = system(@args);
    print "\n";    # Buffer so they can more easily read the output.
    return $ret;
}

sub ssystem_and_die (@args) {
    ssystem(@args) or return 0;
    die "command failed. Fix it and run command.";
}

sub _init_logger ( $debug_level = 'DEBUG') {

    # We have to sprinkle in the screen parts to the config but only when it's enabled.
    my $config = qq{
        log4perl.appender.Screen=Log::Log4perl::Appender::ScreenColoredLevels
        log4perl.appender.Screen.color.TRACE=cyan
        log4perl.appender.Screen.color.DEBUG=bold white
        log4perl.appender.Screen.color.WARN=yellow
        log4perl.appender.Screen.stderr=0
        log4perl.appender.Screen.layout=Log::Log4perl::Layout::PatternLayout
        log4perl.appender.Screen.layout.ConversionPattern=* %d{dd-HH:mm:ss} (%L) [%p] %m%n
        log4perl.category = $debug_level, Screen
    };

    return Log::Log4perl->init( \$config );
}
1;
